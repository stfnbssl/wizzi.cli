module
    kind react
    import 
        @ createHash
        @ randomBytes
        from 'crypto'
    import 
        @ query
            as q
        from 'faunadb'
    const Adapter
        => 
            param config
            param options
                =
                    { 
            const 
                { 
                    @ faunaClient
                    @ collections
                        =
                            { 
                                @ User 'users'
                                @ Account 'accounts'
                                @ Session 'sessions'
                                @ VerificationRequest 'verification_requests'
                    @ indexes
                        =
                            { 
                                @ Account 'account_by_provider_account_id'
                                @ User 'user_by_email'
                                @ Session 'session_by_token'
                                @ VerificationRequest 'verification_request_by_token_and_identifier'
                = config
            async-function getAdapter
                param appOptions
                function _debug
                    param debugCode
                    param ...args
                    # eslint-disable-next-line unicorn/consistent-function-scoping
                const defaultSessionMaxAge = 30 * 24 * 60 * 60 * 1000
                const sessionMaxAge
                    iif appOptions && appOptions.session && appOptions.session.maxAge
                        then appOptions.session.maxAge * 1000
                        else defaultSessionMaxAge
                const sessionUpdateAge
                    iif appOptions && appOptions.session && appOptions.session.updateAge
                        then appOptions.session.updateAge * 1000
                        else 0
                async-function createUser
                    param profile
                    _ _debug('createUser', profile)
                    const FQL
                        _ q.Create
                            _ q.Collection(collections.User)
                            { 
                                { data
                                    @ name profile.name
                                    @ email profile.email
                                    @ image profile.image
                                    @ emailVerified
                                        iif profile.emailVerified
                                            then q.Time(profile.emailVerified.toISOString())
                                            else null
                                    @ username profile.username
                                    @ createdAt q.Now()
                                    @ updatedAt q.Now()
                    try 
                        const newUser
                            await 
                                _ faunaClient.query(FQL)
                        set newUser.data.id = newUser.ref.id
                        return newUser.data
                    catch error
                        _ console.error('CREATE_USER', error)
                        return Promise.reject(Error('CREATE_USER'))
                async-function getUser
                    param id
                    _ _debug('getUser', id)
                    const FQL = q.Get(q.Ref(q.Collection(collections.User), id))
                    try 
                        const user
                            await 
                                _ faunaClient.query(FQL)
                        set user.data.id = user.ref.id
                        return user.data
                    catch error
                        _ console.error('GET_USER', error)
                        return Promise.reject(Error('GET_USER'))
                async-function getUserByEmail
                    param email
                    _ _debug('getUserByEmail', email)
                    if !email
                        return null
                    const FQL
                        _ q.Let
                            { 
                                @ ref q.Match(q.Index(indexes.User), email)
                            _ q.If(q.Exists(q.Var('ref')), q.Get(q.Var('ref')), null)
                    try 
                        const user
                            await 
                                _ faunaClient.query(FQL)
                        if user === null
                            return null
                        set user.data.id = user.ref.id
                        return user.data
                    catch error
                        _ console.error('GET_USER_BY_EMAIL', error)
                        return Promise.reject(Error('GET_USER_BY_EMAIL'))
                async-function getUserByProviderAccountId
                    param providerId
                    param providerAccountId
                    _ _debug('getUserByProviderAccountId', providerId, providerAccountId)
                    const FQL
                        _ q.Let
                            { 
                                @ ref
                                    _ q.Match
                                        _ q.Index(indexes.Account)
                                        [ 
                                            @ providerId
                                            @ providerAccountId
                            _ q.If
                                _ q.Exists(q.Var('ref'))
                                _ q.Get
                                    _ q.Ref
                                        _ q.Collection(collections.User)
                                        _ q.Select
                                            [ 
                                                @ 'data'
                                                @ 'userId'
                                            _ q.Get(q.Var('ref'))
                                @ null
                    try 
                        const user
                            await 
                                _ faunaClient.query(FQL)
                        if user === null
                            return null
                        set user.data.id = user.ref.id
                        return user.data
                    catch error
                        _ console.error('GET_USER_BY_PROVIDER_ACCOUNT_ID', error)
                        return Promise.reject(Error('GET_USER_BY_PROVIDER_ACCOUNT_ID'))
                async-function updateUser
                    param user
                    _ _debug('updateUser', user)
                    const FQL
                        _ q.Update
                            _ q.Ref(q.Collection(collections.User), user.id)
                            { 
                                { data
                                    @ name user.name
                                    @ email user.email
                                    @ image user.image
                                    @ emailVerified
                                        iif user.emailVerified
                                            then q.Time(user.emailVerified.toISOString())
                                            else null
                                    @ username user.username
                                    @ updatedAt q.Now()
                    try 
                        const user
                            await 
                                _ faunaClient.query(FQL)
                        set user.data.id = user.ref.id
                        return user.data
                    catch error
                        _ console.error('UPDATE_USER_ERROR', error)
                        return Promise.reject(Error('UPDATE_USER_ERROR'))
                async-function deleteUser
                    param userId
                    _ _debug('deleteUser', userId)
                    const FQL = q.Delete(q.Ref(q.Collection(collections.User), userId))
                    try 
                        await 
                            _ faunaClient.query(FQL)
                    catch error
                        _ console.error('DELETE_USER_ERROR', error)
                        return Promise.reject(Error('DELETE_USER_ERROR'))
                async-function linkAccount
                    param userId
                    param providerId
                    param providerType
                    param providerAccountId
                    param refreshToken
                    param accessToken
                    param accessTokenExpires
                    _ _debug('linkAccount', userId, providerId, providerType, providerAccountId, refreshToken, accessToken, accessTokenExpires)
                    try 
                        const account
                            await 
                                _ faunaClient.query
                                    _ q.Create
                                        _ q.Collection(collections.Account)
                                        { 
                                            { data
                                                @ userId
                                                @ providerId
                                                @ providerType
                                                @ providerAccountId
                                                @ refreshToken
                                                @ accessToken
                                                @ accessTokenExpires
                                                @ createdAt q.Now()
                                                @ updatedAt q.Now()
                        return account.data
                    catch error
                        _ console.error('LINK_ACCOUNT_ERROR', error)
                        return Promise.reject(Error('LINK_ACCOUNT_ERROR'))
                async-function unlinkAccount
                    param userId
                    param providerId
                    param providerAccountId
                    _ _debug('unlinkAccount', userId, providerId, providerAccountId)
                    const FQL
                        _ q.Delete
                            _ q.Select
                                @ 'ref'
                                _ q.Get
                                    _ q.Match
                                        _ q.Index(indexes.Account)
                                        [ 
                                            @ providerId
                                            @ providerAccountId
                    try 
                        await 
                            _ faunaClient.query(FQL)
                    catch error
                        _ console.error('UNLINK_ACCOUNT_ERROR', error)
                        return Promise.reject(Error('UNLINK_ACCOUNT_ERROR'))
                async-function createSession
                    param user
                    _ _debug('createSession', user)
                    let expires = null
                    if sessionMaxAge
                        const dateExpires = new Date()
                        _ dateExpires.setTime(dateExpires.getTime() + sessionMaxAge)
                        set expires = dateExpires.toISOString()
                    const FQL
                        _ q.Create
                            _ q.Collection(collections.Session)
                            { 
                                { data
                                    @ userId user.id
                                    @ expires q.Time(expires)
                                    @ sessionToken randomBytes(32).toString('hex')
                                    @ accessToken randomBytes(32).toString('hex')
                                    @ createdAt q.Now()
                                    @ updatedAt q.Now()
                    try 
                        const session
                            await 
                                _ faunaClient.query(FQL)
                        set session.data.id = session.ref.id
                        return session.data
                    catch error
                        _ console.error('CREATE_SESSION_ERROR', error)
                        return Promise.reject(Error('CREATE_SESSION_ERROR'))
                async-function getSession
                    param sessionToken
                    _ _debug('getSession', sessionToken)
                    try 
                        const sessionFQL = q.Get(q.Match(q.Index(indexes.Session), sessionToken))
                        const session
                            await 
                                _ faunaClient.query
                                    { 
                                        @ id
                                            _ q.Select
                                                [ 
                                                    @ 'ref'
                                                    @ 'id'
                                                @ sessionFQL
                                        @ userId
                                            _ q.Select
                                                [ 
                                                    @ 'data'
                                                    @ 'userId'
                                                @ sessionFQL
                                        @ expires
                                            _ q.ToMillis
                                                _ q.Select
                                                    [ 
                                                        @ 'data'
                                                        @ 'expires'
                                                    @ sessionFQL
                                        @ sessionToken
                                            _ q.Select
                                                [ 
                                                    @ 'data'
                                                    @ 'sessionToken'
                                                @ sessionFQL
                                        @ accessToken
                                            _ q.Select
                                                [ 
                                                    @ 'data'
                                                    @ 'accessToken'
                                                @ sessionFQL
                                        @ createdAt
                                            _ q.ToMillis
                                                _ q.Select
                                                    [ 
                                                        @ 'data'
                                                        @ 'createdAt'
                                                    @ sessionFQL
                                        @ updatedAt
                                            _ q.ToMillis
                                                _ q.Select
                                                    [ 
                                                        @ 'data'
                                                        @ 'updatedAt'
                                                    @ sessionFQL
                            # Check session has not expired (do not return it if it has)
                        if session && session.expires && new Date() > session.expires
                            await 
                                _ _deleteSession(sessionToken)
                            return null
                        return session
                    catch error
                        _ console.error('GET_SESSION_ERROR', error)
                        return Promise.reject(Error('GET_SESSION_ERROR'))
                async-function updateSession
                    param session
                    param force
                    _ _debug('updateSession', session)
                    try 
                        const shouldUpdate = sessionMaxAge && (sessionUpdateAge || sessionUpdateAge === 0) && session.expires
                        if !shouldUpdate && !force
                            return null
                        const dateSessionIsDueToBeUpdated = new Date(session.expires)
                            # Calculate last updated date, to throttle write updates to database
                            # Formula: ({expiry date} - sessionMaxAge) + sessionUpdateAge
                            # e.g. ({expiry date} - 30 days) + 1 hour
                            # 
                            # Default for sessionMaxAge is 30 days.
                            # Default for sessionUpdateAge is 1 hour.
                        _ dateSessionIsDueToBeUpdated.setTime(dateSessionIsDueToBeUpdated.getTime() - sessionMaxAge)
                        _ dateSessionIsDueToBeUpdated.setTime(dateSessionIsDueToBeUpdated.getTime() + sessionUpdateAge)
                            # Trigger update of session expiry date and write to database, only
                            # if the session was last updated more than {sessionUpdateAge} ago
                        const currentDate = new Date()
                            # Trigger update of session expiry date and write to database, only
                            # if the session was last updated more than {sessionUpdateAge} ago
                        if currentDate < dateSessionIsDueToBeUpdated && !force
                            return null
                        const newExpiryDate = new Date()
                        _ newExpiryDate.setTime(newExpiryDate.getTime() + sessionMaxAge)
                        const updatedSession
                            await 
                                _ faunaClient.query
                                    _ q.Update
                                        _ q.Ref(q.Collection(collections.Session), session.id)
                                        { 
                                            { data
                                                @ expires q.Time(newExpiryDate.toISOString())
                                                @ updatedAt q.Time(new Date().toISOString())
                        set updatedSession.data.id = updatedSession.ref.id
                        return updatedSession.data
                    catch error
                        _ console.error('UPDATE_SESSION_ERROR', error)
                        return Promise.reject(Error('UPDATE_SESSION_ERROR'))
                    # eslint-disable-next-line unicorn/consistent-function-scoping
                async-function _deleteSession
                    param sessionToken
                    const FQL = q.Delete(q.Select('ref', q.Get(q.Match(q.Index(indexes.Session), sessionToken))))
                    return faunaClient.query(FQL)
                    # eslint-disable-next-line unicorn/consistent-function-scoping
                async-function deleteSession
                    param sessionToken
                    _ _debug('deleteSession', sessionToken)
                    try 
                        return 
                            await 
                                _ _deleteSession(sessionToken)
                    catch error
                        _ console.error('DELETE_SESSION_ERROR', error)
                        return Promise.reject(Error('DELETE_SESSION_ERROR'))
                async-function createVerificationRequest
                    param identifier
                    param url
                    param token
                    param secret
                    param provider
                    _ _debug('createVerificationRequest', identifier)
                    const 
                        { 
                            @ baseUrl
                        = appOptions
                    const 
                        { 
                            @ sendVerificationRequest
                            @ maxAge
                        = provider
                        # Store hashed token (using secret as salt) so that tokens cannot be exploited
                        # even if the contents of the database is compromised
                        # @TODO Use bcrypt function here instead of simple salted hash
                    const hashedToken
                        _ createHash('sha256').update
                            `lit 
                                + 
                                @ token
                                + 
                                @ secret
                                + 
                            ._ digest
                                @ 'hex'
                        # Store hashed token (using secret as salt) so that tokens cannot be exploited
                        # even if the contents of the database is compromised
                        # @TODO Use bcrypt function here instead of simple salted hash
                    let expires = null
                    if maxAge
                        const dateExpires = new Date()
                        _ dateExpires.setTime(dateExpires.getTime() + maxAge * 1000)
                        set expires = dateExpires.toISOString()
                    const FQL
                        _ q.Create
                            _ q.Collection(collections.VerificationRequest)
                            { 
                                { data
                                    @ identifier
                                    @ token hashedToken
                                    @ expires
                                        iif expires === null
                                            then null
                                            else q.Time(expires)
                                    @ createdAt q.Now()
                                    @ updatedAt q.Now()
                    try 
                        const verificationRequest
                            await 
                                _ faunaClient.query(FQL)
                            # With the verificationCallback on a provider, you can send an email, or queue
                            # an email to be sent, or perform some other action (e.g. send a text message)
                        await 
                            _ sendVerificationRequest
                                { 
                                    @ identifier
                                    @ url
                                    @ token
                                    @ baseUrl
                                    @ provider
                            # With the verificationCallback on a provider, you can send an email, or queue
                            # an email to be sent, or perform some other action (e.g. send a text message)
                        return verificationRequest.data
                    catch error
                        _ console.error('CREATE_VERIFICATION_REQUEST_ERROR', error)
                        return Promise.reject(Error('CREATE_VERIFICATION_REQUEST_ERROR'))
                async-function getVerificationRequest
                    param identifier
                    param token
                    param secret
                    param provider
                    _ _debug('getVerificationRequest', identifier, token)
                    const hashedToken
                        _ createHash('sha256').update
                            `lit 
                                + 
                                @ token
                                + 
                                @ secret
                                + 
                            ._ digest
                                @ 'hex'
                    const FQL
                        _ q.Let
                            { 
                                @ ref
                                    _ q.Match
                                        _ q.Index(indexes.VerificationRequest)
                                        [ 
                                            @ hashedToken
                                            @ identifier
                            _ q.If
                                _ q.Exists(q.Var('ref'))
                                { 
                                    @ ref q.Var('ref')
                                    @ request q.Select('data', q.Get(q.Var('ref')))
                                @ null
                    try 
                        const 
                            { 
                                @ ref
                                @ request verificationRequest
                            =
                                await 
                                    _ faunaClient.query(FQL)
                        const nowDate = Date.now()
                        if verificationRequest && verificationRequest.expires && verificationRequest.expires < nowDate
                            await 
                                _ faunaClient.query(q.Delete(ref))
                                # Delete the expired request so it cannot be used
                            return null
                        return verificationRequest
                    catch error
                        _ console.error('GET_VERIFICATION_REQUEST_ERROR', error)
                        return Promise.reject(Error('GET_VERIFICATION_REQUEST_ERROR'))
                async-function deleteVerificationRequest
                    param identifier
                    param token
                    param secret
                    param provider
                    _ _debug('deleteVerification', identifier, token)
                    const hashedToken
                        _ createHash('sha256').update
                            `lit 
                                + 
                                @ token
                                + 
                                @ secret
                                + 
                            ._ digest
                                @ 'hex'
                    const FQL
                        _ q.Delete
                            _ q.Select
                                @ 'ref'
                                _ q.Get
                                    _ q.Match
                                        _ q.Index(indexes.VerificationRequest)
                                        [ 
                                            @ hashedToken
                                            @ identifier
                    try 
                        await 
                            _ faunaClient.query(FQL)
                    catch error
                        _ console.error('DELETE_VERIFICATION_REQUEST_ERROR', error)
                        return Promise.reject(Error('DELETE_VERIFICATION_REQUEST_ERROR'))
                return 
                    _ Promise.resolve
                        { 
                            @ createUser
                            @ getUser
                            @ getUserByEmail
                            @ getUserByProviderAccountId
                            @ updateUser
                            @ deleteUser
                            @ linkAccount
                            @ unlinkAccount
                            @ createSession
                            @ getSession
                            @ updateSession
                            @ deleteSession
                            @ createVerificationRequest
                            @ getVerificationRequest
                            @ deleteVerificationRequest
            return 
                { 
                    @ getAdapter
    const adapter
        { 
            @ Adapter
        # eslint-disable-next-line import/no-default-export
    export-default adapter
        # eslint-disable-next-line import/no-default-export
