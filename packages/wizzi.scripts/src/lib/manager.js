/*
    artifact generator: C:\My\wizzi\stfnbssl\wizzi.plugins\packages\wizzi.plugin.js\lib\artifacts\js\module\gen\main.js
    package: wizzi-js@
    primary source IttfDocument: C:\My\wizzi\stfnbssl\wizzi.cli\packages\wizzi.scripts\.wizzi-override\src\lib\manager.js.ittf
    utc time: Sun, 11 Jun 2023 13:19:30 GMT
*/
'use strict';
// generated by wizzi.plugin.js.artifacts.js.module.gen.main
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var path = require('path');
var util = require('util');
var file = require('wizzi-utils').file;
var verify = require('wizzi-utils').verify;
var cp = require("child_process");
// var npm = require('npm')
var babelParser = null;
var babelCore = null;
var prettier = null;
var webpack = null;
var MemoryFS = null;
var memoryFS = null;
const DEFAULT_PRETTIER_CONFIG = {
    bracketSpacing: true, 
    jsxBracketSameLine: false, 
    parser: "babylon", 
    printWidth: 80, 
    semi: true, 
    singleQuote: false, 
    tabWidth: 2, 
    trailingComma: "none", 
    useTabs: false
 };
var Manager = (function () {
    function Manager() {
        _classCallCheck(this, Manager);
    }
    Manager.prototype.spawnExec = function(options, callback) {
        var res = options.__res;
        if (res) {
            res.writeHead(200, {
                "Content-Type": "text/event-stream", 
                "Cache-control": "no-cache"
             })
        }
        var temp,
            str = "",
            stdout = [],
            resEnded = false,
            sentCallback = false;
        var spw = cp.spawn(options.command, options.args, {
            cwd: options.cwd, 
            env: {
                
             }, 
            argv0: undefined, 
            stdio: undefined, 
            detached: false, 
            shell: options.shell || true, 
            windowsVerbatimArguments: false, 
            windowsHide: false
         });
        spw.stdout.on('data', function(data) {
            temp = data.toString();
            console.log(temp, __filename);
            stdout.push(temp);
            if (res && !resEnded) {
                str += temp;
                var lines = str.split("\n");
                for (var i in lines) {
                    if (i == lines.length - 1) {
                        str = lines[i];
                    }
                    // Note: The double-newline is *required*
                    else {
                        res.write('data: ' + lines[i] + "\n\n");
                    }
                }
            }
        })
        spw.on('close', function(code) {
            console.log("close", code, __filename);
            if (res && !resEnded) {
                res.write('data: ***___CLOSE___***\n\n');
                res.end(str);
                resEnded = true;
            }
            if (callback && sentCallback == false) {
                sentCallback = true;
                return callback(null, {
                        error: false, 
                        stdout: stdout
                     });
            }
        })
        spw.stderr.on('data', function(data) {
            temp = data.toString();
            console.log("stderr:", temp, __filename);
            if (res && !resEnded) {
                str += temp;
                var lines = str.split("\n");
                for (var i in lines) {
                    if (i == lines.length - 1) {
                        str = lines[i];
                    }
                    // Note: The double-newline is *required*
                    // TODO _ res.end('stderr: ' + temp)
                    else {
                        res.write('data: ' + lines[i] + "\n\n");
                    }
                }
                res.write('data: ***___CLOSE___***\n\n');
                res.end(str);
                resEnded = true;
            }
            if (callback && sentCallback == false) {
                sentCallback = true;
                return callback(null, {
                        error: true, 
                        stderr: temp
                     });
            }
        })
    }
    Manager.prototype.spawnExecToEventStream = function(options, res, callback) {
        options.__res = res;
        this.spawnExec(options, callback)
    }
    Manager.prototype.gitExec = function(options, callback) {
        this.powershellExec({
            scriptPath: options.scriptPath, 
            params: options.params
         }, callback)
    }
    Manager.prototype.gitExecToEventStream = function(options, res, callback) {
        this.powershellExecToEventStream({
            scriptPath: options.scriptPath, 
            params: options.params
         }, res, callback)
    }
    Manager.prototype.nodeJsExec = function(options, callback) {
        var scriptPath = options.scriptPath;
        var scriptArgs = options.args;
        var args = [path.basename(scriptPath)];
        if (scriptArgs && scriptArgs.length > 0) {
            args = args.concat(scriptArgs);
        }
        this.spawnExec({
            command: 'node', 
            cwd: path.dirname(scriptPath), 
            args: args
         }, callback)
    }
    Manager.prototype.nodeJsExecToEventStream = function(options, res, callback) {
        var scriptPath = options.scriptPath;
        var scriptArgs = options.args;
        var args = [path.basename(scriptPath)];
        if (scriptArgs && scriptArgs.length > 0) {
            args = args.concat(scriptArgs);
        }
        this.spawnExecToEventStream({
            command: 'node', 
            cwd: path.dirname(scriptPath), 
            args: args
         }, res, callback)
    }
    Manager.prototype.babelParseRequire = function(options) {
        if (!babelParser) {
            babelParser = require("@babel/parser");
        }
    }
    Manager.prototype.babelParseExec = function(options, callback) {
        this.babelParseRequire(options)
        var code = options.code;
        var codePath = options.codePath;
        // loog 'wizzi-scripts.babelParseExec codePath, code', codePath, code
        var cfg = this.getBabelParseConfig(options);
        
        // loog 'babelParseExec.cfg', cfg
        if (codePath) {
            var ast = this.cleanBabelAst(options, babelParser.parse(file.read(codePath), cfg));
            return callback(null, ast);
        }
        // loog 'babelParseExec.cfg', cfg
        // loog 'babelParseExec.ast', ast
        /**
            // babelParser.parse
                // code
                // cfg
                // 
                    // err
                        // 
                            // callback
                                // err
                    // ast
                        // this.cleanBabelAst
                            // options
                            // result
                    // 
                        // callback
                            // null
                            // ast
        */
        else {
            var ast = this.cleanBabelAst(options, babelParser.parse(code, cfg));
            return callback(null, ast);
        }
    }
    Manager.prototype.babelParseExecToEventStream = function(options, res, callback) {
        this.babelParseExec(options, (err, result) => {
        
            res.writeHead(200, {
                "Content-Type": "text/event-stream", 
                "Cache-control": "no-cache"
             })
            
            // _ res.write('stderr: ' + JSON.stringify(err, null, 2))
            if (err) {
                res.write('data: ' + JSON.stringify(err, null, 2));
                res.end('data: ***___CLOSE___***\n\n');
            }
            // loog 'wizzi-scripts.babelParseExecToEventStream'
            else {
                var resultString = JSON.stringify(result, null, 2);
                var str;
                var lines = resultString.split("\n");
                for (var i in lines) {
                    if (i == lines.length - 1) {
                        str = lines[i];
                    }
                    // Note: The double-newline is *required*
                    else {
                        res.write('data: ' + lines[i] + "\n\n");
                    }
                }
                if (str.length > 0) {
                    res.write('data: ' + str + "\n\n");
                }
                res.end('data: ***___CLOSE___***\n\n');
            }
            if (callback) {
                return callback(null, result);
            }
        }
        )
    }
    Manager.prototype.cleanBabelAst = function(options, ast) {
        var removeLocation = options.removeLocation;
        if (removeLocation) {
            delete ast.loc
            delete ast.start
            delete ast.end
            var i, i_items=Object.keys(ast), i_len=Object.keys(ast).length, k;
            for (i=0; i<i_len; i++) {
                k = Object.keys(ast)[i];
                if (verify.isArray(ast[k])) {
                    var j, j_items=ast[k], j_len=ast[k].length, node;
                    for (j=0; j<j_len; j++) {
                        node = ast[k][j];
                        this.cleanBabelAst(options, node);
                    }
                }
                if (verify.isObject(ast[k])) {
                    this.cleanBabelAst(options, ast[k]);
                }
            }
        }
        return ast;
    }
    Manager.prototype.babelTransformRequire = function(options) {
        if (!babelCore) {
            babelCore = require("@babel/core");
        }
    }
    Manager.prototype.getBabelTransformConfig = function(options) {
        // TODO calculate cfg from options
        var cfg = 
        /**
            * plugins
                * 
                    * "@babel/plugin-proposal-decorators"
                    * 
                        * "legacy"  true
                * "@babel/plugin-proposal-function-sent"
                * "@babel/plugin-proposal-export-namespace-from"
                * "@babel/plugin-proposal-numeric-separator"
                * "@babel/plugin-proposal-throw-expressions"
                * stage 3
                * "@babel/plugin-syntax-dynamic-import"
                * "@babel/plugin-syntax-import-meta"
                * 
                    * "@babel/plugin-proposal-class-properties"
                    * 
                        * loose false
                * "@babel/plugin-proposal-json-strings"
        */
        {
            presets: [
                "@babel/preset-env", 
                "@babel/preset-react", 
                "@babel/preset-flow"
            ]
         };
        return cfg;
    }
    Manager.prototype.babelTransformExec = function(options, callback) {
        this.babelTransformRequire(options)
        var code = options.code;
        var codePath = options.codePath;
        // loog 'wizzi-scripts.babelTransformExec.codePath', codePath
        var cfg = this.getBabelTransformConfig(options);
        if (codePath) {
            babelCore.transformFile(codePath, cfg, callback)
        }
        else {
            babelCore.transform(code, cfg, callback)
        }
    }
    Manager.prototype.babelTransformExecToEventStream = function(options, res, callback) {
        this.babelTransformExec(options, (err, result) => {
        
            // loog 'wizzi-scripts.babelTransformExecToEventStream.err.result', err, result
            res.writeHead(200, {
                "Content-Type": "text/event-stream", 
                "Cache-control": "no-cache"
             })
            var payload;
            if (err) {
                payload = util.inspect(err);
            }
            // TODO calculate payload from options
            else {
                var payload = result.code;
            }
            // loog 'payload', payload
            var str;
            var lines = payload.split("\n");
            for (var i in lines) {
                if (i == lines.length - 1) {
                    str = lines[i];
                }
                // Note: The double-newline is *required*
                else {
                    res.write('data: ' + lines[i] + "\n\n");
                }
            }
            if (str.length > 0) {
                res.write('data: ' + str + "\n\n");
            }
            res.end('data: ***___CLOSE___***\n\n');
            if (callback) {
                return callback(null, payload);
            }
        }
        )
    }
    Manager.prototype.flowExec = function(options, callback) {
        var codePath = options.codePath;
        var codeArgs = options.args;
        var args = ['flow'];
        if (codeArgs && codeArgs.length > 0) {
            args = args.concat(codeArgs);
        }
        this.spawnExec({
            command: 'npx', 
            cwd: path.dirname(codePath), 
            args: args
         }, callback)
    }
    Manager.prototype.flowExecToEventStream = function(options, res, callback) {
        var codePath = options.codePath;
        var codeArgs = options.args;
        var args = ['flow'];
        if (codeArgs && codeArgs.length > 0) {
            args = args.concat(codeArgs);
        }
        this.spawnExecToEventStream({
            command: 'npx', 
            cwd: path.dirname(codePath), 
            args: args
         }, res, callback)
    }
    Manager.prototype.prettierRequire = function(options) {
        if (!prettier) {
            prettier = require("prettier");
        }
    }
    Manager.prototype.getPrettierConfig = function(options) {
        // TODO calculate cfg from options
        // TODO prettier.resolveConfig(filePath [, options])
        var cfg = options;
        var result = {
            printWidth: cfg.printWidth || 80, 
            tabWidth: typeof cfg.tabWidth === 'undefined' ? 2 : cfg.tabWidth, 
            useTabs: typeof cfg.useTabs === 'undefined' ? true : cfg.useTabs, 
            semi: typeof cfg.semi === 'undefined' ? true : cfg.semi, 
            singleQuote: cfg.singleQuote, 
            trailingComma: typeof cfg.trailingComma === 'undefined' ?  "none" : cfg.trailingComma, 
            bracketSpacing: typeof cfg.bracketSpacing === 'undefined' ? true : cfg.bracketSpacing, 
            jsxBracketSameLine: cfg.jsxBracketSameLine, 
            arrowParens: typeof cfg.arrowParens === 'undefined' ?  "avoid" : cfg.arrowParens, 
            parser: typeof cfg.parser === 'undefined' ?  "babylon" : cfg.parser, 
            filepath: cfg.filepath, 
            requirePragma: cfg.requirePragma, 
            insertPragma: cfg.insertPragma, 
            proseWrap: typeof cfg.proseWrap === 'preserve' ?  "avoid" : cfg.proseWrap
         };
        return result;
    }
    Manager.prototype.prettierExec = function(options, callback) {
        this.prettierRequire(options)
        var code = options.code;
        var codePath = options.codePath;
        var plugins = options.plugins || [];
        var cfg = this.getPrettierConfig(options);
        if (codePath) {
            var prettified = prettier.format(file.read(codePath), cfg, plugins);
            return callback(null, prettified);
        }
        else {
            var prettified = prettier.format(code, cfg, plugins);
            return callback(null, prettified);
        }
    }
    Manager.prototype.prettierExecToEventStream = function(options, res, callback) {
        this.prettierExec(options, (err, result) => {
        
            // loog 'wizzi-scripts.prettierExecToEventStream.err.result', err, result
            res.writeHead(200, {
                "Content-Type": "text/event-stream", 
                "Cache-control": "no-cache"
             })
            var payload;
            if (err) {
                payload = util.inspect(err);
            }
            // TODO calculate payload from options
            else {
                var payload = result;
            }
            // loog 'payload', payload
            var str;
            var lines = payload.split("\n");
            for (var i in lines) {
                if (i == lines.length - 1) {
                    str = lines[i];
                }
                // Note: The double-newline is *required*
                else {
                    res.write('data: ' + lines[i] + "\n\n");
                }
            }
            if (str.length > 0) {
                res.write('data: ' + str + "\n\n");
            }
            res.end('data: ***___CLOSE___***\n\n');
            if (callback) {
                return callback(null, payload);
            }
        }
        )
    }
    Manager.prototype.eslintExec = function(options, callback) {
        var filePath = options.filePath;
        var packagePath = options.packagePath;
        var folder = options.folder;
        var codeArgs = options.args;
        var args = [folder];
        if (codeArgs && codeArgs.length > 0) {
            args = args.concat(codeArgs);
        }
        this.spawnExec({
            command: '"./node_modules/.bin/eslint"', 
            cwd: packagePath, 
            args: args
         }, callback)
    }
    Manager.prototype.eslintExecToEventStream = function(options, res, callback) {
        var filePath = options.filePath;
        var packagePath = options.packagePath;
        var folder = options.folder;
        var codeArgs = options.args;
        var args = [folder];
        if (codeArgs && codeArgs.length > 0) {
            args = args.concat(codeArgs);
        }
        this.spawnExecToEventStream({
            command: '"./node_modules/.bin/eslint"', 
            cwd: packagePath, 
            args: args
         }, res, callback)
    }
    Manager.prototype.webpackRequire = function(options) {
        if (!webpack) {
            webpack = require("webpack");
        }
        if (options.memoryFS && !MemoryFS) {
            MemoryFS = require('memory-fs');
            memoryFS = new MemoryFS();
        }
    }
    Manager.prototype.getWebpackConfig = function(options) {
        // TODO calculate cfg from options
        var cfg = options;
        cfg.rules = [];
        if (cfg.useReact) {
            cfg.rules.push({
                test: /\.(js|jsx)$/, 
                exclude: /node_modules/, 
                use: {
                    loader: 'babel-loader', 
                    options: {
                        presets: [
                            '@babel/preset-env', 
                            '@babel/preset-react'
                        ]
                     }
                 }
             })
        }
        // https://webpack.js.org/configuration/
        return {
                mode: cfg.mode || 'development', 
                entry: cfg.entry || './src', 
                
                // the target directory for all output files
                
                // must be an absolute path (use the Node.js path module)
                
                // the filename template for entry chunks
                
                // the url to the output directory resolved relative to the HTML page
                
                // the name of the exported library
                
                // universal module definition // the type of the exported library
                output: {
                    path: (cfg.output && cfg.output.path) || path.resolve(__dirname, "dist"), 
                    filename: cfg.filename || "bundle.js", 
                    publicPath: cfg.publicPath || "/assets/", 
                    library: cfg.library, 
                    libraryTarget: cfg.libraryTarget
                 }, 
                module: {
                    rules: cfg.rules || []
                 }
             };
    }
    Manager.prototype.webpackExec = function(options, callback) {
        this.webpackRequire(options)
        const compiler = webpack(this.getWebpackConfig(options));
        if (options.memoryFS) {
            compiler.outputFileSystem = memoryFS;
        }
        function run_cb(err, stats) {
            if (err) {
                console.error(err.stack || err);
                if (err.details) {
                    console.error(err.details);
                }
                return ;
            }
            const info = stats.toJson();
            if (stats.hasErrors()) {
                console.error(info.errors);
            }
            if (stats.hasWarnings()) {
                console.warn(info.warnings);
            }
            // Done processing
            console.log(stats.toString(
            // Makes the build much quieter
            
            // Shows colors in the console
            {
                chunks: false, 
                colors: true
             }))
        }
        if (options.watch) {
            compiler.watch(
            // Example watchOptions
            {
                aggregateTimeout: 300, 
                poll: undefined
             }, run_cb)
        }
        else {
            compiler.run(run_cb)
        }
    }
    Manager.prototype.webpackExecToEventStream = function(options, res, callback) {
        throw new Error('Not implemented');
    }
    return Manager;
})();

module.exports = Manager;
