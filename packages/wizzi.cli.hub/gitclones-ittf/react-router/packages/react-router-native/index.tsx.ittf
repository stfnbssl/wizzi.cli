module
    import 
        as React
        from "react"
    :import-type 
        @ GestureResponderEvent
        @ TouchableHighlightProps
        from "react-native"
    import 
        @ BackHandler
        @ Linking
        @ TouchableHighlight
        from "react-native"
    :import-type 
        @ To
        @ MemoryRouterProps
        @ NavigateOptions
        @ RelativeRoutingType
        from "react-router"
    import 
        @ MemoryRouter
        @ useLocation
        @ useNavigate
        from "react-router"
    import URLSearchParams from "@ungap/url-search-params"
        # //////////////////////////////////////////////////////////////////////////////
        # RE-EXPORTS
        # //////////////////////////////////////////////////////////////////////////////
        # Note: Keep in sync with react-router exports!
    export 
        @ ActionFunction
        @ ActionFunctionArgs
        @ AwaitProps
        @ Blocker
        @ BlockerFunction
        @ DataRouteMatch
        @ DataRouteObject
        @ ErrorResponse
        @ Fetcher
        @ FutureConfig
        @ Hash
        @ IndexRouteObject
        @ IndexRouteProps
        @ JsonFunction
        @ LazyRouteFunction
        @ LayoutRouteProps
        @ LoaderFunction
        @ LoaderFunctionArgs
        @ Location
        @ MemoryRouterProps
        @ NavigateFunction
        @ NavigateOptions
        @ NavigateProps
        @ Navigation
        @ Navigator
        @ NonIndexRouteObject
        @ OutletProps
        @ Params
        @ ParamParseKey
        @ Path
        @ PathMatch
        @ Pathname
        @ PathParam
        @ PathPattern
        @ PathRouteProps
        @ RedirectFunction
        @ RelativeRoutingType
        @ RouteMatch
        @ RouteObject
        @ RouteProps
        @ RouterProps
        @ RouterProviderProps
        @ RoutesProps
        @ Search
        @ ShouldRevalidateFunction
        @ ShouldRevalidateFunctionArgs
        @ To
        @ UIMatch
        from "react-router"
        # //////////////////////////////////////////////////////////////////////////////
        # RE-EXPORTS
        # //////////////////////////////////////////////////////////////////////////////
        # Note: Keep in sync with react-router exports!
    export 
        @ AbortedDeferredError
        @ Await
        @ MemoryRouter
        @ Navigate
        @ NavigationType
        @ Outlet
        @ Route
        @ Router
        @ RouterProvider
        @ Routes
        @ createMemoryRouter
        @ createPath
        @ createRoutesFromChildren
        @ createRoutesFromElements
        @ defer
        @ isRouteErrorResponse
        @ generatePath
        @ json
        @ matchPath
        @ matchRoutes
        @ parsePath
        @ redirect
        @ redirectDocument
        @ renderMatches
        @ resolvePath
        @ useActionData
        @ useAsyncError
        @ useAsyncValue
        @ useBlocker
        @ useHref
        @ useInRouterContext
        @ useLoaderData
        @ useLocation
        @ useMatch
        @ useMatches
        @ useNavigate
        @ useNavigation
        @ useNavigationType
        @ useOutlet
        @ useOutletContext
        @ useParams
        @ useResolvedPath
        @ useRevalidator
        @ useRouteError
        @ useRouteLoaderData
        @ useRoutes
        from "react-router"
        # /////////////////////////////////////////////////////////////////////////////
        # DANGER! PLEASE READ ME!
        # We provide these exports as an escape hatch in the event that you need any
        # routing data that we don't provide an explicit API for. With that said, we
        # want to cover your use case if we can, so if you feel the need to use these
        # we want to hear from you. Let us know what you're building and we'll do our
        # best to make sure we can support you!
        # 
        # We consider these exports an implementation detail and do not guarantee
        # against any breaking changes, regardless of the semver release. Use with
        # extreme caution and only if you understand the consequences. Godspeed.
        # /////////////////////////////////////////////////////////////////////////////
        #
            # * @internal
    export 
        @ UNSAFE_DataRouterContext
        @ UNSAFE_DataRouterStateContext
        @ UNSAFE_NavigationContext
        @ UNSAFE_LocationContext
        @ UNSAFE_RouteContext
        @ UNSAFE_useRouteId
        from "react-router"
        # /////////////////////////////////////////////////////////////////////////////
        # DANGER! PLEASE READ ME!
        # We provide these exports as an escape hatch in the event that you need any
        # routing data that we don't provide an explicit API for. With that said, we
        # want to cover your use case if we can, so if you feel the need to use these
        # we want to hear from you. Let us know what you're building and we'll do our
        # best to make sure we can support you!
        # 
        # We consider these exports an implementation detail and do not guarantee
        # against any breaking changes, regardless of the semver release. Use with
        # extreme caution and only if you understand the consequences. Godspeed.
        # /////////////////////////////////////////////////////////////////////////////
        #
            # * @internal
        # //////////////////////////////////////////////////////////////////////////////
        # COMPONENTS
        # //////////////////////////////////////////////////////////////////////////////
    export 
        :interface NativeRouterProps
            :extends MemoryRouterProps
        # //////////////////////////////////////////////////////////////////////////////
        # COMPONENTS
        # //////////////////////////////////////////////////////////////////////////////
        #
            # *
            # * A `<Router>` that runs on React Native.
            # 
    export 
        function NativeRouter
            param props
                :ref NativeRouterProps
            return 
                < MemoryRouter 
                    @ {...props}
        #
            # *
            # * A `<Router>` that runs on React Native.
            # 
    export 
        :interface LinkProps
            :extends TouchableHighlightProps
            :p children
                :optional 
                :ref React.ReactNode
            :p onPress
                :optional 
                :=> 
                    :void 
                    param event
                        :ref GestureResponderEvent
            :p relative
                :optional 
                :ref RelativeRoutingType
            :p replace
                :optional 
                :boolean 
            :p state
                :optional 
                :any 
            :p to
                :ref To
        #
            # *
            # * A `<TouchableHighlight>` that navigates to a different URL when touched.
            # 
    export 
        function Link
            { 
                @ onPress
                @ relative
                @ replace
                    = false
                @ state
                @ to
                ... rest
                :ref LinkProps
            let internalOnPress
                _ useLinkPressHandler
                    @ to
                    { 
                        @ replace
                        @ state
                        @ relative
            function handlePress
                param event
                    :ref GestureResponderEvent
                if onPress
                    _ onPress(event)
                if !event.defaultPrevented
                    _ internalOnPress(event)
            return 
                < TouchableHighlight 
                    @ {...rest}
                    @ onPress {handlePress}
        #
            # *
            # * A `<TouchableHighlight>` that navigates to a different URL when touched.
            # 
        # //////////////////////////////////////////////////////////////////////////////
        # HOOKS
        # //////////////////////////////////////////////////////////////////////////////
    const HardwareBackPressEventType = "hardwareBackPress"
        # //////////////////////////////////////////////////////////////////////////////
        # HOOKS
        # //////////////////////////////////////////////////////////////////////////////
    const URLEventType = "url"
        #
            # *
            # * Handles the press behavior for router `<Link>` components. This is useful if
            # * you need to create custom `<Link>` components with the same press behavior we
            # * use in our exported `<Link>`.
            # 
    export 
        function useLinkPressHandler
            param to
                :ref To
            param 
                @ replace
                @ state
                @ relative
                :{ 
                    :p replace
                        :optional 
                        :boolean 
                    :p state
                        :optional 
                        :any 
                    :p relative
                        :optional 
                        :ref RelativeRoutingType
                = 
            :return
                :=> 
                    :void 
                    param event
                        :ref GestureResponderEvent
            let navigate = useNavigate()
            return 
                function handlePress
                    _ navigate
                        @ to
                        { 
                            @ replace
                            @ state
                            @ relative
        #
            # *
            # * Handles the press behavior for router `<Link>` components. This is useful if
            # * you need to create custom `<Link>` components with the same press behavior we
            # * use in our exported `<Link>`.
            # 
        #
            # *
            # * Enables support for the hardware back button on Android.
            # 
    export 
        function useHardwareBackButton
            _ React.useEffect
                => 
                    function handleHardwardBackPress
                        return undefined
                            # TODO: The implementation will be something like this
                            # if (history.index === 0) {
                            # return false; // home screen
                            # } else {
                            # history.back();
                            # return true;
                            # }
                    _ BackHandler.addEventListener(HardwareBackPressEventType, handleHardwardBackPress)
                    return 
                        => 
                            _ BackHandler.removeEventListener(HardwareBackPressEventType, handleHardwardBackPress)
                [ 
        #
            # *
            # * Enables support for the hardware back button on Android.
            # 
    export 
        @ useHardwareBackButton
            as useAndroidBackButton
        #
            # *
            # * Enables deep linking, both on the initial app launch and for
            # * subsequent incoming links.
            # 
    export 
        function useDeepLinking
            let navigate = useNavigate()
                # Get the initial URL
            _ React.useEffect
                => 
                    let current = true
                    _ Linking.getInitialURL().then
                        => 
                            param url
                            if current
                                if url
                                    _ navigate(trimScheme(url))
                    return 
                        => 
                            set current = false
                [ 
                    @ navigate
                # Get the initial URL
                # Listen for URL changes
            _ React.useEffect
                => 
                    function handleURLChange
                        param event
                            :{ 
                                :p url
                                    :string 
                        _ navigate(trimScheme(event.url))
                    _ Linking.addEventListener(URLEventType, handleURLChange)
                    return 
                        => 
                            _ Linking.removeEventListener(URLEventType, handleURLChange)
                [ 
                    @ navigate
                # Listen for URL changes
        #
            # *
            # * Enables deep linking, both on the initial app launch and for
            # * subsequent incoming links.
            # 
    function trimScheme
        param url
            :string 
        return url.replace(/^.*?:\/\//, "")
        #
            # *
            # * A convenient wrapper for accessing individual query parameters via the
            # * URLSearchParams interface.
            # 
    export 
        function useSearchParams
            param defaultInit
                :ref URLSearchParamsInit
                :optional 
            :return
                :tuple 
                    :ref URLSearchParams
                    :ref SetURLSearchParams
            let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit))
            let hasSetSearchParamsRef = React.useRef(false)
            let location = useLocation()
            let searchParams
                _ React.useMemo
                    => 
                        let searchParams = createSearchParams(location.search)
                        if !hasSetSearchParamsRef.current
                            for 
                                left
                                    let key
                                of defaultSearchParamsRef.current.keys()
                                if !searchParams.has(key)
                                    _ defaultSearchParamsRef.current.getAll(key).forEach
                                        => 
                                            param value
                                            _ searchParams.append(key, value)
                        return searchParams
                    [ 
                        @ location.search
            let navigate = useNavigate()
            let setSearchParams
                _ React.useCallback
                    :param 
                        :ref SetURLSearchParams
                    => 
                        param nextInit
                        param navigateOpts
                        const newSearchParams
                            _ createSearchParams
                                iif typeof nextInit === "function"
                                    then nextInit(searchParams)
                                    else nextInit
                        set hasSetSearchParamsRef.current = true
                        _ navigate("?" + newSearchParams, navigateOpts)
                    [ 
                        @ navigate
                        @ searchParams
            return 
                [ 
                    @ searchParams
                    @ setSearchParams
        #
            # *
            # * A convenient wrapper for accessing individual query parameters via the
            # * URLSearchParams interface.
            # 
    export 
        :type SetURLSearchParams
            :=> 
                :void 
                param nextInit
                    :union 
                        :ref URLSearchParamsInit
                        :paren 
                            :=> 
                                :ref URLSearchParamsInit
                                param prev
                                    :ref URLSearchParams
                    :optional 
                param navigateOpts
                    :ref NavigateOptions
                    :optional 
    export 
        :type ParamKeyValuePair
            :tuple 
                :string 
                :string 
    export 
        :type URLSearchParamsInit
            :union 
                :string 
                :[ 
                    :ref ParamKeyValuePair
                :ref Record
                    :param string
                    :param 
                        :union 
                            :string 
                            :[ 
                                :string 
                :ref URLSearchParams
        #
            # *
            # * Creates a URLSearchParams object using the given initializer.
            # *
            # * This is identical to `new URLSearchParams(init)` except it also
            # * supports arrays as values in the object form of the initializer
            # * instead of just strings. This is convenient when you need multiple
            # * values for a given key, but don't want to use an array initializer.
            # *
            # * For example, instead of:
            # *
            # *   let searchParams = new URLSearchParams([
            # *     ['sort', 'name'],
            # *     ['sort', 'price']
            # *   ]);
            # *
            # * you can do:
            # *
            # *   let searchParams = createSearchParams({
            # *     sort: ['name', 'price']
            # *   });
            # 
    export 
        function createSearchParams
            param init
                :ref URLSearchParamsInit
                = ""
            :return
                :ref URLSearchParams
            return 
                new URLSearchParams
                    iif typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams
                        then init
                        else
                            _ Object.keys(init).reduce
                                => 
                                    param memo
                                    param key
                                    let value = init[key]
                                    return 
                                        _ memo.concat
                                            iif Array.isArray(value)
                                                then
                                                    _ value.map
                                                        => 
                                                            param v
                                                            [ 
                                                                @id key
                                                                @id v
                                                else
                                                    [ 
                                                        [ 
                                                            @id key
                                                            @id value
                                [ []
                                    :as 
                                        :[ 
                                            :ref ParamKeyValuePair
        #
            # *
            # * Creates a URLSearchParams object using the given initializer.
            # *
            # * This is identical to `new URLSearchParams(init)` except it also
            # * supports arrays as values in the object form of the initializer
            # * instead of just strings. This is convenient when you need multiple
            # * values for a given key, but don't want to use an array initializer.
            # *
            # * For example, instead of:
            # *
            # *   let searchParams = new URLSearchParams([
            # *     ['sort', 'name'],
            # *     ['sort', 'price']
            # *   ]);
            # *
            # * you can do:
            # *
            # *   let searchParams = createSearchParams({
            # *     sort: ['name', 'price']
            # *   });
            # 
