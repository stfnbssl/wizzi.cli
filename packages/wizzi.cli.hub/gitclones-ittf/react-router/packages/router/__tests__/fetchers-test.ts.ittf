module
    :import-type 
        @ FutureConfig
        @ HydrationState
        from "../index"
        #
            # eslint-disable jest/valid-title
    import 
        @ createMemoryHistory
        @ createRouter
        @ IDLE_FETCHER
        @ IDLE_NAVIGATION
        from "../index"
        # Private API
    import 
        @ ErrorResponseImpl
        from "../utils"
        # Private API
    import 
        @ cleanup
        @ createDeferred
        @ setup
        @ TASK_ROUTES
        from "./utils/data-router-setup"
    import 
        @ createFormData
        @ tick
        from "./utils/utils"
    function initializeTest
        param init
            :{ 
                :p url
                    :optional 
                    :string 
                :p hydrationData
                    :optional 
                    :ref HydrationState
                :p future
                    :optional 
                    :ref Partial
                        :param 
                            :ref FutureConfig
            :optional 
        return 
            _ setup
                { 
                    [ routes
                        { 
                            @ path ""
                            @ id "root"
                            @ hasErrorBoundary true
                            @ loader true
                            [ children
                                { 
                                    @ path "/"
                                    @ id "index"
                                    @ loader true
                                    @ action true
                                { 
                                    @ path "/foo"
                                    @ id "foo"
                                    @ loader true
                                    @ action true
                                { 
                                    @ path "/foo/bar"
                                    @ id "foobar"
                                    @ loader true
                                    @ action true
                                { 
                                    @ path "/bar"
                                    @ id "bar"
                                    @ loader true
                                    @ action true
                                { 
                                    @ path "/baz"
                                    @ id "baz"
                                    @ loader true
                                    @ action true
                    @ hydrationData
                        || 
                            + init?.hydrationData
                            { 
                                { loaderData
                                    @ root "ROOT"
                                    @ index "INDEX"
                    @ future init?.future
                    ... 
                        ( 
                            iif init?.url
                                then
                                    { 
                                        [ initialEntries
                                            @ init.url
                                else
                                    { 
    _ describe
        @ "fetchers"
        => 
            _ beforeEach
                => 
                    _ jest.spyOn(console, "warn").mockImplementation
                        => 
                # Detect any failures inside the router navigate code
            _ afterEach
                => 
                    _ cleanup()
                        # @ts-ignore
                    _ console.warn.mockReset()
                        # @ts-ignore
                # Detect any failures inside the router navigate code
            _ describe
                @ "fetcher states"
                => 
                    _ it
                        @ "unabstracted loader fetch"
                        async=> 
                            let dfd = createDeferred()
                            let router
                                _ createRouter
                                    { 
                                        @ history
                                            _ createMemoryHistory
                                                { 
                                                    [ initialEntries
                                                        @ "/"
                                        [ routes
                                            { 
                                                @ id "root"
                                                @ path "/"
                                                @ loader
                                                    => 
                                                        +
                                                            @expr dfd.promise
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT DATA"
                            let key = "key"
                            _ router.fetch(key, "root", "/")
                            _ expect(router.state.fetchers.get(key)).toEqual
                                { 
                                    @ state "loading"
                                    @ formMethod undefined
                                    @ formEncType undefined
                                    @ formData undefined
                                    @ data undefined
                            await 
                                _ dfd.resolve("DATA")
                            _ expect(router.state.fetchers.get(key)).toEqual
                                { 
                                    @ state "idle"
                                    @ formMethod undefined
                                    @ formEncType undefined
                                    @ formData undefined
                                    @ data "DATA"
                            _ expect(router._internalFetchControllers.size).toBe(0)
                    _ it
                        @ "loader fetch"
                        async=> 
                            let t
                                _ initializeTest
                                    { 
                                        @ url "/foo"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ foo "FOO"
                            let A
                                await 
                                    _ t.fetch("/foo")
                            _ expect(A.fetcher.state).toBe("loading")
                            await 
                                _ A.loaders.foo.resolve("A DATA")
                            _ expect(A.fetcher.state).toBe("idle")
                            _ expect(A.fetcher.data).toBe("A DATA")
                    _ it
                        @ "loader re-fetch"
                        async=> 
                            let t
                                _ initializeTest
                                    { 
                                        @ url "/foo"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ foo "FOO"
                            let key = "key"
                            let A
                                await 
                                    _ t.fetch("/foo", key)
                            await 
                                _ A.loaders.foo.resolve("A DATA")
                            _ expect(A.fetcher.state).toBe("idle")
                            _ expect(A.fetcher.data).toBe("A DATA")
                            let B
                                await 
                                    _ t.fetch("/foo", key)
                            _ expect(B.fetcher.state).toBe("loading")
                            _ expect(B.fetcher.data).toBe("A DATA")
                            await 
                                _ B.loaders.foo.resolve("B DATA")
                            _ expect(B.fetcher.state).toBe("idle")
                            _ expect(B.fetcher.data).toBe("B DATA")
                            _ expect(A.fetcher).toBe(B.fetcher)
                    _ it
                        @ "loader submission fetch"
                        async=> 
                            let t
                                _ initializeTest
                                    { 
                                        @ url "/foo"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ foo "FOO"
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        { 
                                            @ formMethod "get"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            _ expect(A.fetcher.state).toBe("loading")
                            _ expect(A.fetcher.formMethod).toBe("get")
                            _ expect(A.fetcher.formAction).toBe("/foo")
                            _ expect(A.fetcher.formData).toEqual
                                _ createFormData
                                    { 
                                        @ key "value"
                            _ expect(A.fetcher.formEncType).toBe("application/x-www-form-urlencoded")
                            _ expect(new URL(A.loaders.foo.stub.mock.calls[0][0].request.url).searchParams.toString()).toBe("key=value")
                            await 
                                _ A.loaders.foo.resolve("A DATA")
                            _ expect(A.fetcher.state).toBe("idle")
                            _ expect(A.fetcher.data).toBe("A DATA")
                    _ it
                        @ "loader submission re-fetch"
                        async=> 
                            let t
                                _ initializeTest
                                    { 
                                        @ url "/foo"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ foo "FOO"
                            let key = "key"
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        @ key
                                        { 
                                            @ formMethod "get"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            _ expect(A.fetcher.state).toBe("loading")
                            await 
                                _ A.loaders.foo.resolve("A DATA")
                            _ expect(A.fetcher.state).toBe("idle")
                            _ expect(A.fetcher.data).toBe("A DATA")
                            let B
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        @ key
                                        { 
                                            @ formMethod "get"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            _ expect(B.fetcher.state).toBe("loading")
                            _ expect(B.fetcher.data).toBe("A DATA")
                            await 
                                _ B.loaders.foo.resolve("B DATA")
                            _ expect(A.fetcher.state).toBe("idle")
                            _ expect(A.fetcher.data).toBe("B DATA")
                    _ it
                        @ "action fetch"
                        async=> 
                            let t
                                _ initializeTest
                                    { 
                                        @ url "/foo"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ foo "FOO"
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            _ expect(A.fetcher.state).toBe("submitting")
                            await 
                                _ A.actions.foo.resolve("A ACTION")
                            _ expect(A.fetcher.state).toBe("loading")
                            _ expect(A.fetcher.data).toBe("A ACTION")
                            await 
                                _ A.loaders.root.resolve("ROOT DATA")
                            _ expect(A.fetcher.state).toBe("loading")
                            _ expect(A.fetcher.data).toBe("A ACTION")
                            await 
                                _ A.loaders.foo.resolve("A DATA")
                            _ expect(A.fetcher.state).toBe("idle")
                            _ expect(A.fetcher.data).toBe("A ACTION")
                            _ expect(t.router.state.loaderData).toEqual
                                { 
                                    @ root "ROOT DATA"
                                    @ foo "A DATA"
                    _ it
                        @ "action re-fetch"
                        async=> 
                            let t
                                _ initializeTest
                                    { 
                                        @ url "/foo"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ foo "FOO"
                            let key = "key"
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        @ key
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            _ expect(A.fetcher.state).toBe("submitting")
                            await 
                                _ A.actions.foo.resolve("A ACTION")
                            _ expect(A.fetcher.state).toBe("loading")
                            _ expect(A.fetcher.data).toBe("A ACTION")
                            await 
                                _ A.loaders.root.resolve("ROOT DATA")
                            await 
                                _ A.loaders.foo.resolve("A DATA")
                            _ expect(A.fetcher.state).toBe("idle")
                            _ expect(A.fetcher.data).toBe("A ACTION")
                            let B
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        @ key
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            _ expect(B.fetcher.state).toBe("submitting")
                            _ expect(B.fetcher.data).toBe("A ACTION")
                            await 
                                _ B.actions.foo.resolve("B ACTION")
                            await 
                                _ B.loaders.root.resolve("ROOT DATA*")
                            await 
                                _ B.loaders.foo.resolve("A DATA*")
                            _ expect(B.fetcher.state).toBe("idle")
                            _ expect(B.fetcher.data).toBe("B ACTION")
            _ describe
                @ "fetcher removal"
                => 
                    _ it
                        @ "gives an idle fetcher before submission"
                        async=> 
                            let t = initializeTest()
                            let fetcher = t.router.getFetcher("randomKey")
                            _ expect(fetcher).toBe(IDLE_FETCHER)
                    _ it
                        @ "removes fetchers"
                        async=> 
                            let t = initializeTest()
                            let A
                                await 
                                    _ t.fetch("/foo")
                            await 
                                _ A.loaders.foo.resolve("A")
                            _ expect(t.router.getFetcher(A.key).data).toBe("A")
                            _ t.router.deleteFetcher(A.key)
                            _ expect(t.router.getFetcher(A.key)).toBe(IDLE_FETCHER)
                    _ it
                        @ "cleans up abort controllers"
                        async=> 
                            let t = initializeTest()
                            let A
                                await 
                                    _ t.fetch("/foo")
                            _ expect(t.router._internalFetchControllers.size).toBe(1)
                            let B
                                await 
                                    _ t.fetch("/bar")
                            _ expect(t.router._internalFetchControllers.size).toBe(2)
                            await 
                                _ A.loaders.foo.resolve(null)
                            _ expect(t.router._internalFetchControllers.size).toBe(1)
                            await 
                                _ B.loaders.bar.resolve(null)
                            _ expect(t.router._internalFetchControllers.size).toBe(0)
                    _ it
                        @ "uses current page matches and URL when reloading routes after submissions"
                        async=> 
                            let pagePathname = "/foo"
                            let t
                                _ initializeTest
                                    { 
                                        @ url pagePathname
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ foo "FOO"
                            let A
                                await 
                                    _ t.fetch
                                        @ "/bar"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            await 
                                _ A.actions.bar.resolve("ACTION")
                            await 
                                _ A.loaders.root.resolve("ROOT DATA")
                            await 
                                _ A.loaders.foo.resolve("FOO DATA")
                            _ expect(t.router.state.loaderData).toEqual
                                { 
                                    @ root "ROOT DATA"
                                    @ foo "FOO DATA"
                            _ expect(A.loaders.root.stub).toHaveBeenCalledWith
                                { 
                                    { params
                                    @ request
                                        new Request
                                            @ "http://localhost/foo"
                                            { 
                                                @ signal A.loaders.root.stub.mock.calls[0][0].request.signal
            _ describe
                @ "fetcher removal (w/v7_fetcherPersist)"
                => 
                    _ it
                        @ "loading fetchers persist until completion"
                        async=> 
                            let t
                                _ initializeTest
                                    { 
                                        { future
                                            @ v7_fetcherPersist true
                            let key = "key"
                            _ t.router.getFetcher(key)
                                # mount
                            _ expect(t.router.state.fetchers.size).toBe(0)
                                # mount
                            let A
                                await 
                                    _ t.fetch("/foo", key)
                            _ expect(t.router.state.fetchers.size).toBe(1)
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                            _ t.router.deleteFetcher(key)
                                # unmount
                            _ expect(t.router.state.fetchers.size).toBe(1)
                                # unmount
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                                # Cleaned up on completion
                            await 
                                _ A.loaders.foo.resolve("FOO")
                                # Cleaned up on completion
                            _ expect(t.router.state.fetchers.size).toBe(0)
                    _ it
                        @ "submitting fetchers persist until completion when removed during submitting phase"
                        async=> 
                            let t
                                _ initializeTest
                                    { 
                                        { future
                                            @ v7_fetcherPersist true
                            let key = "key"
                            _ expect(t.router.state.fetchers.size).toBe(0)
                            _ t.router.getFetcher(key)
                                # mount
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        @ key
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                # mount
                            _ expect(t.router.state.fetchers.size).toBe(1)
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("submitting")
                            _ t.router.deleteFetcher(key)
                                # unmount
                            _ expect(t.router.state.fetchers.size).toBe(1)
                                # unmount
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("submitting")
                            await 
                                _ A.actions.foo.resolve("FOO")
                            _ expect(t.router.state.fetchers.size).toBe(1)
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                                # Cleaned up on completion
                            await 
                                _ A.loaders.root.resolve("ROOT*")
                                # Cleaned up on completion
                            _ expect(t.router.state.fetchers.size).toBe(1)
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                            await 
                                _ A.loaders.index.resolve("INDEX*")
                            _ expect(t.router.state.fetchers.size).toBe(0)
                    _ it
                        @ "submitting fetchers persist until completion when removed during loading phase"
                        async=> 
                            let t
                                _ initializeTest
                                    { 
                                        { future
                                            @ v7_fetcherPersist true
                            let key = "key"
                            _ t.router.getFetcher(key)
                                # mount
                            _ expect(t.router.state.fetchers.size).toBe(0)
                                # mount
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        @ key
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                            _ expect(t.router.state.fetchers.size).toBe(1)
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("submitting")
                            await 
                                _ A.actions.foo.resolve("FOO")
                            _ expect(t.router.state.fetchers.size).toBe(1)
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                            _ t.router.deleteFetcher(key)
                                # unmount
                            _ expect(t.router.state.fetchers.size).toBe(1)
                                # unmount
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                                # Cleaned up on completion
                            await 
                                _ A.loaders.root.resolve("ROOT*")
                                # Cleaned up on completion
                            _ expect(t.router.state.fetchers.size).toBe(1)
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                            await 
                                _ A.loaders.index.resolve("INDEX*")
                            _ expect(t.router.state.fetchers.size).toBe(0)
                    _ it
                        @ "unmounted fetcher.load errors/redirects should not be processed"
                        async=> 
                            let t
                                _ initializeTest
                                    { 
                                        { future
                                            @ v7_fetcherPersist true
                            _ t.router.getFetcher("a")
                                # mount
                            let A
                                await 
                                    _ t.fetch("/foo", "a")
                                # mount
                            _ t.router.deleteFetcher("a")
                                # unmount
                            await 
                                _ A.loaders.foo.reject("ERROR")
                                # unmount
                            _ expect(t.router.state.fetchers.size).toBe(0)
                            _ expect(t.router.state.errors).toBe(null)
                            _ t.router.getFetcher("b")
                                # mount
                            let B
                                await 
                                    _ t.fetch("/bar", "b")
                                # mount
                            _ t.router.deleteFetcher("b")
                                # unmount
                            await 
                                _ B.loaders.bar.redirect("/baz")
                                # unmount
                            _ expect(t.router.state.fetchers.size).toBe(0)
                            _ expect(t.router.state.navigation).toBe(IDLE_NAVIGATION)
                            _ expect(t.router.state.location.pathname).toBe("/")
                    _ it
                        @ "unmounted fetcher.submit errors/redirects should not be processed"
                        async=> 
                            let t
                                _ initializeTest
                                    { 
                                        { future
                                            @ v7_fetcherPersist true
                            _ t.router.getFetcher("a")
                                # mount
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        @ "a"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                # mount
                            _ t.router.deleteFetcher("a")
                                # unmount
                            await 
                                _ A.actions.foo.reject("ERROR")
                                # unmount
                            _ expect(t.router.state.fetchers.size).toBe(0)
                            _ expect(t.router.state.errors).toBe(null)
                            _ t.router.getFetcher("b")
                                # mount
                            let B
                                await 
                                    _ t.fetch
                                        @ "/bar"
                                        @ "b"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                # mount
                            _ t.router.deleteFetcher("b")
                                # unmount
                            await 
                                _ B.actions.bar.redirect("/baz")
                                # unmount
                            _ expect(t.router.state.fetchers.size).toBe(0)
                            _ expect(t.router.state.navigation).toBe(IDLE_NAVIGATION)
                            _ expect(t.router.state.location.pathname).toBe("/")
            _ describe
                @ "fetcher error states (4xx Response)"
                => 
                    _ it
                        @ "loader fetch"
                        async=> 
                            let t = initializeTest()
                            let A
                                await 
                                    _ t.fetch("/foo")
                            await 
                                _ A.loaders.foo.reject
                                    new Response
                                        @ null
                                        { 
                                            @ status 400
                            _ expect(A.fetcher).toBe(IDLE_FETCHER)
                            _ expect(t.router.state.errors).toEqual
                                { 
                                    @ root new ErrorResponseImpl(400, undefined, "")
                    _ it
                        @ "loader submission fetch"
                        async=> 
                            let t = initializeTest()
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo?key=value"
                                        { 
                                            @ formMethod "get"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            await 
                                _ A.loaders.foo.reject
                                    new Response
                                        @ null
                                        { 
                                            @ status 400
                            _ expect(A.fetcher).toBe(IDLE_FETCHER)
                            _ expect(t.router.state.errors).toEqual
                                { 
                                    @ root new ErrorResponseImpl(400, undefined, "")
                    _ it
                        @ "action fetch"
                        async=> 
                            let t = initializeTest()
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            await 
                                _ A.actions.foo.reject
                                    new Response
                                        @ null
                                        { 
                                            @ status 400
                            _ expect(A.fetcher).toBe(IDLE_FETCHER)
                            _ expect(t.router.state.errors).toEqual
                                { 
                                    @ root new ErrorResponseImpl(400, undefined, "")
                    _ it
                        @ "action fetch without action handler"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "root"
                                                @ path "/"
                                                @ hasErrorBoundary true
                                                [ children
                                                    { 
                                                        @ id "index"
                                                        @ index true
                            let A
                                await 
                                    _ t.fetch
                                        @ "/"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            _ expect(A.fetcher).toBe(IDLE_FETCHER)
                            _ expect(t.router.state.errors).toEqual
                                { 
                                    @ root new ErrorResponseImpl(405, "Method Not Allowed", Error('You made a POST request to "/" but did not provide an `action` ' + 'for route "root", so there is no way to handle the request.'), true)
                    _ it
                        @ "action fetch with invalid body (json)"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "root"
                                                @ path "/"
                                                @ hasErrorBoundary true
                            let A
                                await 
                                    _ t.fetch
                                        @ "/"
                                        { 
                                            @ formMethod "post"
                                            @ body "not json"
                                            @ formEncType "application/json"
                            _ expect(A.fetcher).toBe(IDLE_FETCHER)
                            _ expect(t.router.state.errors).toEqual
                                { 
                                    @ root new ErrorResponseImpl(400, "Bad Request", Error("Unable to encode submission body"), true)
                    _ it
                        @ "handles fetcher errors at contextual route boundaries"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "root"
                                                @ path "/"
                                                @ hasErrorBoundary true
                                                [ children
                                                    { 
                                                        @ id "wit"
                                                        @ path "wit"
                                                        @ loader true
                                                        @ hasErrorBoundary true
                                                    { 
                                                        @ id "witout"
                                                        @ path "witout"
                                                        @ loader true
                                                    { 
                                                        @ id "error"
                                                        @ path "error"
                                                        @ loader true
                                # If the routeId is not an active match, errors bubble to the root
                            let A
                                await 
                                    _ t.fetch("/error", "key1", "wit")
                                # If the routeId is not an active match, errors bubble to the root
                            await 
                                _ A.loaders.error.reject(Error("Kaboom!"))
                            _ expect(t.router.getFetcher("key1")).toBe(IDLE_FETCHER)
                            _ expect(t.router.state.errors).toEqual
                                { 
                                    @ root new Error("Kaboom!")
                            await 
                                _ t.fetch("/not-found", "key2", "wit")
                            _ expect(t.router.getFetcher("key2")).toBe(IDLE_FETCHER)
                            _ expect(t.router.state.errors).toEqual
                                { 
                                    @ root new ErrorResponseImpl(404, "Not Found", Error('No route matches URL "/not-found"'), true)
                                # Navigate to /wit and trigger errors, handled at the wit boundary
                            let B
                                await 
                                    _ t.navigate("/wit")
                                # Navigate to /wit and trigger errors, handled at the wit boundary
                            await 
                                _ B.loaders.wit.resolve("WIT")
                            let C
                                await 
                                    _ t.fetch("/error", "key3", "wit")
                            await 
                                _ C.loaders.error.reject(Error("Kaboom!"))
                            _ expect(t.router.getFetcher("key3")).toBe(IDLE_FETCHER)
                            _ expect(t.router.state.errors).toEqual
                                { 
                                    @ wit new Error("Kaboom!")
                            await 
                                _ t.fetch
                                    @ "/not-found"
                                    @ "key4"
                                    @ "wit"
                                    { 
                                        @ formMethod "post"
                                        @ formData
                                            _ createFormData
                                                { 
                                                    @ key "value"
                            _ expect(t.router.getFetcher("key4")).toBe(IDLE_FETCHER)
                            _ expect(t.router.state.errors).toEqual
                                { 
                                    @ wit new ErrorResponseImpl(404, "Not Found", Error('No route matches URL "/not-found"'), true)
                            await 
                                _ t.fetch("/not-found", "key5", "wit")
                            _ expect(t.router.getFetcher("key5")).toBe(IDLE_FETCHER)
                            _ expect(t.router.state.errors).toEqual
                                { 
                                    @ wit new ErrorResponseImpl(404, "Not Found", Error('No route matches URL "/not-found"'), true)
                                # Navigate to /witout and fetch a 404, handled at the root boundary
                            let D
                                await 
                                    _ t.navigate("/witout")
                                # Navigate to /witout and fetch a 404, handled at the root boundary
                            await 
                                _ D.loaders.witout.resolve("WITOUT")
                            let E
                                await 
                                    _ t.fetch("/error", "key6", "witout")
                            await 
                                _ E.loaders.error.reject(Error("Kaboom!"))
                            _ expect(t.router.getFetcher("key6")).toBe(IDLE_FETCHER)
                            _ expect(t.router.state.errors).toEqual
                                { 
                                    @ root new Error("Kaboom!")
                            await 
                                _ t.fetch("/not-found", "key7", "witout")
                            _ expect(t.router.getFetcher("key7")).toBe(IDLE_FETCHER)
                            _ expect(t.router.state.errors).toEqual
                                { 
                                    @ root new ErrorResponseImpl(404, "Not Found", Error('No route matches URL "/not-found"'), true)
            _ describe
                @ "fetcher error states (Error)"
                => 
                    _ it
                        @ "loader fetch"
                        async=> 
                            let t = initializeTest()
                            let A
                                await 
                                    _ t.fetch("/foo")
                            await 
                                _ A.loaders.foo.reject(Error("Kaboom!"))
                            _ expect(A.fetcher).toBe(IDLE_FETCHER)
                            _ expect(t.router.state.errors).toEqual
                                { 
                                    @ root new Error("Kaboom!")
                    _ it
                        @ "loader submission fetch"
                        async=> 
                            let t = initializeTest()
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo?key=value"
                                        { 
                                            @ formMethod "get"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            await 
                                _ A.loaders.foo.reject(Error("Kaboom!"))
                            _ expect(A.fetcher).toBe(IDLE_FETCHER)
                            _ expect(t.router.state.errors).toEqual
                                { 
                                    @ root new Error("Kaboom!")
                    _ it
                        @ "action fetch"
                        async=> 
                            let t = initializeTest()
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            await 
                                _ A.actions.foo.reject(Error("Kaboom!"))
                            _ expect(A.fetcher).toBe(IDLE_FETCHER)
                            _ expect(t.router.state.errors).toEqual
                                { 
                                    @ root new Error("Kaboom!")
            _ describe
                @ "fetcher redirects"
                => 
                    _ it
                        @ "loader fetch"
                        async=> 
                            let t = initializeTest()
                            let key = t.router.state.location.key
                            let A
                                await 
                                    _ t.fetch("/foo")
                            let B
                                await 
                                    _ A.loaders.foo.redirect("/bar")
                            _ expect(t.router.getFetcher(A.key)).toBe(A.fetcher)
                            _ expect(t.router.state.navigation.state).toBe("loading")
                            _ expect(t.router.state.navigation.location?.pathname).toBe("/bar")
                            await 
                                _ B.loaders.bar.resolve("BAR")
                            _ expect(t.router.state.navigation.state).toBe("idle")
                            _ expect(t.router.state.historyAction).toBe("PUSH")
                            _ expect(t.router.state.location?.pathname).toBe("/bar")
                                # Back button should take us back to location that triggered the fetch
                                # redirect
                            let C
                                await 
                                    _ t.navigate(-1)
                                # Back button should take us back to location that triggered the fetch
                                # redirect
                            await 
                                _ C.loaders.index.resolve("INDEX")
                            _ expect(t.router.state.location.pathname).toBe("/")
                            _ expect(t.router.state.location.key).toBe(key)
                    _ it
                        @ "loader submission fetch"
                        async=> 
                            let t = initializeTest()
                            let key = t.router.state.location.key
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo?key=value"
                                        { 
                                            @ formMethod "get"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            let B
                                await 
                                    _ A.loaders.foo.redirect("/bar")
                            _ expect(t.router.getFetcher(A.key)).toBe(A.fetcher)
                            _ expect(t.router.state.navigation.state).toBe("loading")
                            _ expect(t.router.state.navigation.location?.pathname).toBe("/bar")
                            await 
                                _ B.loaders.bar.resolve("BAR")
                            _ expect(t.router.state.navigation.state).toBe("idle")
                            _ expect(t.router.state.historyAction).toBe("PUSH")
                            _ expect(t.router.state.location?.pathname).toBe("/bar")
                                # Back button should take us back to location that triggered the fetch
                                # redirect
                            let C
                                await 
                                    _ t.navigate(-1)
                                # Back button should take us back to location that triggered the fetch
                                # redirect
                            await 
                                _ C.loaders.index.resolve("INDEX")
                            _ expect(t.router.state.location.pathname).toBe("/")
                            _ expect(t.router.state.location.key).toBe(key)
                    _ it
                        @ "action fetch"
                        async=> 
                            let t = initializeTest()
                            let key = t.router.state.location.key
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            _ expect(A.fetcher.state).toBe("submitting")
                            let AR
                                await 
                                    _ A.actions.foo.redirect("/bar")
                            _ expect(A.fetcher.state).toBe("loading")
                            _ expect(t.router.state.navigation).toMatchObject
                                { 
                                    @ state "loading"
                                    { location
                                        @ pathname "/bar"
                                    @ formAction undefined
                                        # Fetcher action redirect should not proxy the fetcher submission
                                        # onto the loading navigation
                                    @ formData undefined
                                    @ formEncType undefined
                                    @ formMethod undefined
                            await 
                                _ AR.loaders.root.resolve("ROOT*")
                            await 
                                _ AR.loaders.bar.resolve("stuff")
                            _ expect(A.fetcher).toEqual
                                { 
                                    @ data undefined
                                    @ state "idle"
                                    @ formMethod undefined
                                    @ formAction undefined
                                    @ formEncType undefined
                                    @ formData undefined
                            _ expect(t.router.state.historyAction).toBe("PUSH")
                            _ expect(t.router.state.location.pathname).toBe("/bar")
                                # Root loader should be re-called after fetchActionRedirect
                            _ expect(t.router.state.loaderData).toEqual
                                { 
                                    @ root "ROOT*"
                                    @ bar "stuff"
                                # Root loader should be re-called after fetchActionRedirect
                                # Back button should take us back to location that triggered the fetch
                                # redirect
                            let C
                                await 
                                    _ t.navigate(-1)
                                # Back button should take us back to location that triggered the fetch
                                # redirect
                            await 
                                _ C.loaders.index.resolve("INDEX")
                            _ expect(t.router.state.location.pathname).toBe("/")
                            _ expect(t.router.state.location.key).toBe(key)
            _ describe
                @ "fetcher resubmissions/re-gets"
                => 
                    _ it
                        @ "aborts re-gets"
                        async=> 
                            let t = initializeTest()
                            let key = "KEY"
                            let A
                                await 
                                    _ t.fetch("/foo", key)
                            let B
                                await 
                                    _ t.fetch("/foo", key)
                            await 
                                _ A.loaders.foo.resolve(null)
                            let C
                                await 
                                    _ t.fetch("/foo", key)
                            await 
                                _ B.loaders.foo.resolve(null)
                            await 
                                _ C.loaders.foo.resolve(null)
                            _ expect(A.loaders.foo.signal.aborted).toBe(true)
                            _ expect(B.loaders.foo.signal.aborted).toBe(true)
                            _ expect(C.loaders.foo.signal.aborted).toBe(false)
                    _ it
                        @ "aborts re-get-submissions"
                        async=> 
                            let t = initializeTest()
                            let key = "KEY"
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        @ key
                                        { 
                                            @ formMethod "get"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            let B
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        @ key
                                        { 
                                            @ formMethod "get"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            let C
                                await 
                                    _ t.fetch("/foo", key)
                            _ expect(A.loaders.foo.signal.aborted).toBe(true)
                            _ expect(B.loaders.foo.signal.aborted).toBe(true)
                            await 
                                _ C.loaders.foo.resolve(null)
                    _ it
                        @ "aborts resubmissions action call"
                        async=> 
                            let t = initializeTest()
                            let key = "KEY"
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        @ key
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            let B
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        @ key
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            let C
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        @ key
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            _ expect(A.actions.foo.signal.aborted).toBe(true)
                            _ expect(B.actions.foo.signal.aborted).toBe(true)
                            await 
                                _ C.actions.foo.resolve(null)
                            await 
                                _ C.loaders.root.resolve(null)
                            await 
                                _ C.loaders.index.resolve(null)
                    _ it
                        @ "aborts resubmissions loader call"
                        async=> 
                            let t
                                _ initializeTest
                                    { 
                                        @ url "/foo"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ foo "FOO"
                            let key = "KEY"
                            let A
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        @ key
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            await 
                                _ A.actions.foo.resolve("A ACTION")
                            let C
                                await 
                                    _ t.fetch
                                        @ "/foo"
                                        @ key
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                                        @ key "value"
                            _ expect(A.loaders.foo.signal.aborted).toBe(true)
                            await 
                                _ C.actions.foo.resolve(null)
                            await 
                                _ C.loaders.root.resolve(null)
                            await 
                                _ C.loaders.foo.resolve(null)
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) POST |--|--XXX&lf;
                            + &nbsp;     B) POST       |----XXX|XXX&lf;
                            + &nbsp;     C) POST            |----|---O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "aborts A load, ignores A resolve, aborts B action"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/foo"
                                                { hydrationData
                                                    { loaderData
                                                        @ root "ROOT"
                                                        @ foo "FOO"
                                    let key = "KEY"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                @ key
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ A.actions.foo.resolve("A ACTION")
                                    _ expect(t.router.getFetcher(key).data).toBe("A ACTION")
                                    let B
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                @ key
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    _ expect(A.loaders.foo.signal.aborted).toBe(true)
                                    _ expect(t.router.getFetcher(key).data).toBe("A ACTION")
                                    await 
                                        _ A.loaders.root.resolve("A ROOT LOADER")
                                    await 
                                        _ A.loaders.foo.resolve("A LOADER")
                                    _ expect(t.router.state.loaderData.foo).toBe("FOO")
                                    let C
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                @ key
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    _ expect(B.actions.foo.signal.aborted).toBe(true)
                                    await 
                                        _ B.actions.foo.resolve("B ACTION")
                                    _ expect(t.router.getFetcher(key).data).toBe("A ACTION")
                                    await 
                                        _ C.actions.foo.resolve("C ACTION")
                                    _ expect(t.router.getFetcher(key).data).toBe("C ACTION")
                                    await 
                                        _ B.loaders.root.resolve("B ROOT LOADER")
                                    await 
                                        _ B.loaders.foo.resolve("B LOADER")
                                    _ expect(t.router.state.loaderData.foo).toBe("FOO")
                                    await 
                                        _ C.loaders.root.resolve("C ROOT LOADER")
                                    await 
                                        _ C.loaders.foo.resolve("C LOADER")
                                    _ expect(t.router.getFetcher(key).data).toBe("C ACTION")
                                    _ expect(t.router.state.loaderData.foo).toBe("C LOADER")
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) k1 |----|----X&lf;
                            + &nbsp;     B) k2   |----|-----O&lf;
                            + &nbsp;     C) k1           |-----|---O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "aborts A load, commits B and C loads"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/foo"
                                                { hydrationData
                                                    { loaderData
                                                        @ root "ROOT"
                                                        @ foo "FOO"
                                    let k1 = "1"
                                    let k2 = "2"
                                    let Ak1
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                @ k1
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    let Bk2
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                @ k2
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ Ak1.actions.foo.resolve("A ACTION")
                                    await 
                                        _ Bk2.actions.foo.resolve("B ACTION")
                                    _ expect(t.router.getFetcher(k2).data).toBe("B ACTION")
                                    let Ck1
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                @ k1
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    _ expect(Ak1.loaders.foo.signal.aborted).toBe(true)
                                    await 
                                        _ Ak1.loaders.root.resolve("A ROOT LOADER")
                                    await 
                                        _ Ak1.loaders.foo.resolve("A LOADER")
                                    _ expect(t.router.state.loaderData.foo).toBe("FOO")
                                    await 
                                        _ Bk2.loaders.root.resolve("B ROOT LOADER")
                                    await 
                                        _ Bk2.loaders.foo.resolve("B LOADER")
                                    _ expect(Ck1.actions.foo.signal.aborted).toBe(false)
                                    _ expect(t.router.state.loaderData.foo).toBe("B LOADER")
                                    await 
                                        _ Ck1.actions.foo.resolve("C ACTION")
                                    await 
                                        _ Ck1.loaders.root.resolve("C ROOT LOADER")
                                    await 
                                        _ Ck1.loaders.foo.resolve("C LOADER")
                                    _ expect(t.router.getFetcher(k1).data).toBe("C ACTION")
                                    _ expect(t.router.state.loaderData.foo).toBe("C LOADER")
            _ describe
                @ "multiple fetcher action reloads"
                => 
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) POST /foo |---[A]------O&lf;
                            + &nbsp;     B) POST /foo   |-----[A,B]---O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "commits A, commits B"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/foo"
                                                { hydrationData
                                                    { loaderData
                                                        @ root "ROOT"
                                                        @ foo "FOO"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    let B
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ A.actions.foo.resolve("A action")
                                    await 
                                        _ B.actions.foo.resolve("B action")
                                    await 
                                        _ A.loaders.root.resolve("A root")
                                    await 
                                        _ A.loaders.foo.resolve("A loader")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "A root"
                                            @ foo "A loader"
                                    await 
                                        _ B.loaders.root.resolve("A,B root")
                                    await 
                                        _ B.loaders.foo.resolve("A,B loader")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "A,B root"
                                            @ foo "A,B loader"
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) POST /foo |----🧤&lf;
                            + &nbsp;     B) POST /foo   |--X&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "catches A, persists boundary for B"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/foo"
                                                { hydrationData
                                                    { loaderData
                                                        @ root "ROOT"
                                                        @ foo "FOO"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    let B
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ A.actions.foo.reject
                                            new Response
                                                @ null
                                                { 
                                                    @ status 400
                                    _ expect(t.router.state.errors).toEqual
                                        { 
                                            @ root new ErrorResponseImpl(400, undefined, "")
                                    await 
                                        _ B.actions.foo.resolve("B")
                                    _ expect(t.router.state.errors).toEqual
                                        { 
                                            @ root new ErrorResponseImpl(400, undefined, "")
                                    await 
                                        _ B.loaders.root.resolve(null)
                                    await 
                                        _ B.loaders.foo.resolve(null)
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) POST /foo |----[A]-|&lf;
                            + &nbsp;     B) POST /foo   |------🧤&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "commits A, catches B"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/foo"
                                                { hydrationData
                                                    { loaderData
                                                        @ root "ROOT"
                                                        @ foo "FOO"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    let B
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ A.actions.foo.resolve("A action")
                                    await 
                                        _ A.loaders.root.resolve("A root")
                                    await 
                                        _ A.loaders.foo.resolve("A loader")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "A root"
                                            @ foo "A loader"
                                    await 
                                        _ B.actions.foo.reject
                                            new Response
                                                @ null
                                                { 
                                                    @ status 400
                                    _ expect(t.router.state.errors).toEqual
                                        { 
                                            @ root new ErrorResponseImpl(400, undefined, "")
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) POST /foo |---[A]-------X&lf;
                            + &nbsp;     B) POST /foo   |----[A,B]--O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "aborts A, commits B, sets A done"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/foo"
                                                { hydrationData
                                                    { loaderData
                                                        @ root "ROOT"
                                                        @ foo "FOO"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    let B
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ A.actions.foo.resolve("A")
                                    await 
                                        _ B.actions.foo.resolve("B")
                                    await 
                                        _ B.loaders.root.resolve("A,B root")
                                    await 
                                        _ B.loaders.foo.resolve("A,B")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "A,B root"
                                            @ foo "A,B"
                                    _ expect(A.loaders.foo.signal.aborted).toBe(true)
                                    _ expect(A.fetcher.state).toBe("idle")
                                    _ expect(A.fetcher.data).toBe("A")
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) POST /foo |--------[B,A]---O&lf;
                            + &nbsp;     B) POST /foo   |--[B]-------O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "commits B, commits A"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/foo"
                                                { hydrationData
                                                    { loaderData
                                                        @ root "ROOT"
                                                        @ foo "FOO"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    let B
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ B.actions.foo.resolve("B action")
                                    await 
                                        _ A.actions.foo.resolve("A action")
                                    await 
                                        _ B.loaders.root.resolve("B root")
                                    await 
                                        _ B.loaders.foo.resolve("B")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "B root"
                                            @ foo "B"
                                    await 
                                        _ A.loaders.root.resolve("B,A root")
                                    await 
                                        _ A.loaders.foo.resolve("B,A")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "B,A root"
                                            @ foo "B,A"
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) POST /foo |------|---O&lf;
                            + &nbsp;     B) POST /foo   |--|-----X&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "aborts B, commits A, sets B done"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/foo"
                                                { hydrationData
                                                    { loaderData
                                                        @ root "ROOT"
                                                        @ foo "FOO"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    let B
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ B.actions.foo.resolve("B")
                                    await 
                                        _ A.actions.foo.resolve("A")
                                    await 
                                        _ A.loaders.root.resolve("B,A root")
                                    await 
                                        _ A.loaders.foo.resolve("B,A")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "B,A root"
                                            @ foo "B,A"
                                    _ expect(B.loaders.foo.signal.aborted).toBe(true)
                                    _ expect(B.fetcher.state).toBe("idle")
                                    _ expect(B.fetcher.data).toBe("B")
            _ describe
                @ "navigating with inflight fetchers"
                => 
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) fetch POST |-------|--O&lf;
                            + &nbsp;     B) nav GET      |---O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "does not abort A action or data reload"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/foo"
                                                { hydrationData
                                                    { loaderData
                                                        @ root "ROOT"
                                                        @ foo "FOO"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    let B
                                        await 
                                            _ t.navigate("/foo")
                                    _ expect(A.actions.foo.signal.aborted).toBe(false)
                                    _ expect(t.router.state.navigation.state).toBe("loading")
                                    _ expect(t.router.state.navigation.location?.pathname).toBe("/foo")
                                    await 
                                        _ B.loaders.root.resolve("B root")
                                    await 
                                        _ B.loaders.foo.resolve("B")
                                    _ expect(t.router.state.navigation.state).toBe("idle")
                                    _ expect(t.router.state.location.pathname).toBe("/foo")
                                    _ expect(t.router.state.loaderData.foo).toBe("B")
                                    _ expect(A.loaders.foo.signal).toBe(undefined)
                                        # A loaders not called yet
                                    await 
                                        _ A.actions.foo.resolve("A root")
                                        # A loaders not called yet
                                    await 
                                        _ A.loaders.root.resolve("A root")
                                    await 
                                        _ A.loaders.foo.resolve("A")
                                    _ expect(A.loaders.foo.signal.aborted).toBe(false)
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "A root"
                                            @ foo "A"
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) fetch POST |----|-----O&lf;
                            + &nbsp;     B) nav GET      |-----O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "Commits A and uses next matches"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                        # This fetcher's helpers take the current locations loaders (root/index).
                                        # Since we know we're about to interrupt with /foo let's shim in a
                                        # loader helper for foo ahead of time
                                    _ t.shimHelper(A.loaders, "fetch", "loader", "foo")
                                        # This fetcher's helpers take the current locations loaders (root/index).
                                        # Since we know we're about to interrupt with /foo let's shim in a
                                        # loader helper for foo ahead of time
                                    let B
                                        await 
                                            _ t.navigate("/foo")
                                    await 
                                        _ A.actions.foo.resolve("A action")
                                    await 
                                        _ B.loaders.root.resolve("B root")
                                    await 
                                        _ B.loaders.foo.resolve("B")
                                    _ expect(A.actions.foo.signal.aborted).toBe(false)
                                    _ expect(A.loaders.foo.signal.aborted).toBe(false)
                                    _ expect(t.router.state.navigation.state).toBe("idle")
                                    _ expect(t.router.state.location.pathname).toBe("/foo")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "B root"
                                            @ foo "B"
                                    await 
                                        _ A.loaders.root.resolve("A root")
                                    await 
                                        _ A.loaders.foo.resolve("A")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "A root"
                                            @ foo "A"
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) fetch POST |--|----X&lf;
                            + &nbsp;     B) nav GET         |--O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "aborts A, sets fetcher done"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/foo"
                                                { hydrationData
                                                    { loaderData
                                                        @ root "ROOT"
                                                        @ foo "FOO"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ A.actions.foo.resolve("A")
                                    let B
                                        await 
                                            _ t.navigate("/foo")
                                    await 
                                        _ B.loaders.root.resolve("ROOT*")
                                    await 
                                        _ B.loaders.foo.resolve("B")
                                    _ expect(t.router.state.navigation.state).toBe("idle")
                                    _ expect(t.router.state.location.pathname).toBe("/foo")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "ROOT*"
                                            @ foo "B"
                                    _ expect(A.loaders.foo.signal.aborted).toBe(true)
                                    _ expect(A.fetcher.state).toBe("idle")
                                    _ expect(A.fetcher.data).toBe("A")
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) fetch POST |--|---O&lf;
                            + &nbsp;     B) nav GET         |---O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "commits both"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/foo"
                                                { hydrationData
                                                    { loaderData
                                                        @ root "ROOT"
                                                        @ foo "FOO"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ A.actions.foo.resolve("A action")
                                    let B
                                        await 
                                            _ t.navigate("/foo")
                                    await 
                                        _ A.loaders.root.resolve("A ROOT")
                                    await 
                                        _ A.loaders.foo.resolve("A")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "A ROOT"
                                            @ foo "A"
                                    await 
                                        _ B.loaders.root.resolve("B ROOT")
                                    await 
                                        _ B.loaders.foo.resolve("B")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "B ROOT"
                                            @ foo "B"
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) fetch POST |---[A]---O&lf;
                            + &nbsp;     B) nav POST           |---[A,B]--O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "keeps both"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/foo"
                                                { hydrationData
                                                    { loaderData
                                                        @ root "ROOT"
                                                        @ foo "FOO"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ A.actions.foo.resolve("A action")
                                    let B
                                        await 
                                            _ t.navigate
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ A.loaders.root.resolve("A ROOT")
                                    await 
                                        _ A.loaders.foo.resolve("A")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "A ROOT"
                                            @ foo "A"
                                    await 
                                        _ B.actions.foo.resolve("A,B")
                                    await 
                                        _ B.loaders.root.resolve("A,B ROOT")
                                    await 
                                        _ B.loaders.foo.resolve("A,B")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "A,B ROOT"
                                            @ foo "A,B"
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) fetch POST |---[A]--------X&lf;
                            + &nbsp;     B) nav POST     |-----[A,B]--O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "aborts A, commits B, marks fetcher done"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/foo"
                                                { hydrationData
                                                    { loaderData
                                                        @ root "ROOT"
                                                        @ foo "FOO"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    let B
                                        await 
                                            _ t.navigate
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ A.actions.foo.resolve("A")
                                    await 
                                        _ B.actions.foo.resolve("A,B")
                                    await 
                                        _ B.loaders.root.resolve("A,B ROOT")
                                    await 
                                        _ B.loaders.foo.resolve("A,B")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "A,B ROOT"
                                            @ foo "A,B"
                                    _ expect(A.loaders.foo.signal.aborted).toBe(true)
                                    _ expect(A.fetcher.state).toBe("idle")
                                    _ expect(A.fetcher.data).toBe("A")
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) fetch POST |-----------[B,A]--O&lf;
                            + &nbsp;     B) nav POST     |--[B]--O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "commits both, uses the nav's href"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/foo"
                                                { hydrationData
                                                    { loaderData
                                                        @ root "ROOT"
                                                        @ foo "FOO"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    _ t.shimHelper(A.loaders, "fetch", "loader", "bar")
                                    let B
                                        await 
                                            _ t.navigate
                                                @ "/bar"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ B.actions.bar.resolve("B")
                                    await 
                                        _ B.loaders.root.resolve("B")
                                    await 
                                        _ B.loaders.bar.resolve("B")
                                    await 
                                        _ A.actions.foo.resolve("B,A")
                                    await 
                                        _ A.loaders.root.resolve("B,A ROOT")
                                    await 
                                        _ A.loaders.bar.resolve("B,A")
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "B,A ROOT"
                                            @ bar "B,A"
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) fetch POST |-------[B,A]--O&lf;
                            + &nbsp;     B) nav POST     |--[B]-------X&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "aborts B, commits A, uses the nav's href"
                                async=> 
                                    let t
                                        _ initializeTest
                                            { 
                                                @ url "/foo"
                                                { hydrationData
                                                    { loaderData
                                                        @ root "ROOT"
                                                        @ foo "FOO"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    _ t.shimHelper(A.loaders, "fetch", "loader", "bar")
                                    let B
                                        await 
                                            _ t.navigate
                                                @ "/bar"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ B.actions.bar.resolve("B")
                                    await 
                                        _ A.actions.foo.resolve("B,A")
                                    await 
                                        _ A.loaders.root.resolve("B,A ROOT")
                                    await 
                                        _ A.loaders.bar.resolve("B,A")
                                    _ expect(B.loaders.bar.signal.aborted).toBe(true)
                                    _ expect(t.router.state.loaderData).toEqual
                                        { 
                                            @ root "B,A ROOT"
                                            @ bar "B,A"
                                    _ expect(t.router.state.navigation).toBe(IDLE_NAVIGATION)
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) fetch POST /foo |--X&lf;
                            + &nbsp;     B) nav   GET  /bar    |-----O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "forces all loaders to revalidate on interrupted fetcher submission"
                                async=> 
                                    let t = initializeTest()
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    _ t.shimHelper(A.loaders, "fetch", "loader", "bar")
                                        # Interrupting the submission should cause the next load to call all loaders
                                    let B
                                        await 
                                            _ t.navigate("/bar")
                                        # Interrupting the submission should cause the next load to call all loaders
                                    await 
                                        _ A.actions.foo.resolve("A ACTION")
                                    await 
                                        _ B.loaders.root.resolve("ROOT*")
                                    await 
                                        _ B.loaders.bar.resolve("BAR")
                                    _ expect(t.router.state).toMatchObject
                                        { 
                                            @ navigation IDLE_NAVIGATION
                                            { location
                                                @ pathname "/bar"
                                            @ actionData null
                                            { loaderData
                                                @ root "ROOT*"
                                                @ bar "BAR"
                                    await 
                                        _ A.loaders.root.resolve("ROOT**")
                                    await 
                                        _ A.loaders.bar.resolve("BAR*")
                                    _ expect(t.router.state).toMatchObject
                                        { 
                                            @ navigation IDLE_NAVIGATION
                                            { location
                                                @ pathname "/bar"
                                            @ actionData null
                                            { loaderData
                                                @ root "ROOT**"
                                                @ bar "BAR*"
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) fetch POST /foo |--|--X&lf;
                            + &nbsp;     B) nav   GET  /bar       |-----O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "forces all loaders to revalidate on interrupted fetcher actionReload"
                                async=> 
                                    let key = "key"
                                    let t = initializeTest()
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                @ key
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ A.actions.foo.resolve("A ACTION")
                                    _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                                    _ expect(t.router.state.fetchers.get(key)?.data).toBe("A ACTION")
                                        # Interrupting the actionReload should cause the next load to call all loaders
                                    let B
                                        await 
                                            _ t.navigate("/bar")
                                        # Interrupting the actionReload should cause the next load to call all loaders
                                    await 
                                        _ B.loaders.root.resolve("ROOT*")
                                    await 
                                        _ B.loaders.bar.resolve("BAR")
                                    _ expect(t.router.state).toMatchObject
                                        { 
                                            @ navigation IDLE_NAVIGATION
                                            { location
                                                @ pathname "/bar"
                                            @ actionData null
                                            { loaderData
                                                @ root "ROOT*"
                                                @ bar "BAR"
                                    _ expect(t.router.state.fetchers.get(key)?.state).toBe("idle")
                                    _ expect(t.router.state.fetchers.get(key)?.data).toBe("A ACTION")
                            _ it
                                @ "forces all loaders to revalidate on interrupted fetcher submissionRedirect"
                                async=> 
                                    let key = "key"
                                    let t = initializeTest()
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                @ key
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ A.actions.foo.redirect("/baz")
                                    _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                                        # Interrupting the actionReload should cause the next load to call all loaders
                                    let B
                                        await 
                                            _ t.navigate("/bar")
                                        # Interrupting the actionReload should cause the next load to call all loaders
                                    await 
                                        _ B.loaders.root.resolve("ROOT*")
                                    await 
                                        _ B.loaders.bar.resolve("BAR")
                                    _ expect(t.router.state).toMatchObject
                                        { 
                                            @ navigation IDLE_NAVIGATION
                                            { location
                                                @ pathname "/bar"
                                            { loaderData
                                                @ root "ROOT*"
                                                @ bar "BAR"
                                    _ expect(t.router.state.fetchers.get(key)?.state).toBe("idle")
                                    _ expect(t.router.state.fetchers.get(key)?.data).toBeUndefined()
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) fetch GET /foo |--R&lf;
                            + &nbsp;     B) nav   GET /bar   |---O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "ignores loader redirect navigation if preceded by a normal GET navigation"
                                async=> 
                                    let key = "key"
                                    let t = initializeTest()
                                        # Start a fetch load and interrupt with a navigation
                                    let A
                                        await 
                                            _ t.fetch("/foo", key)
                                        # Start a fetch load and interrupt with a navigation
                                    let B
                                        await 
                                            _ t.navigate("/bar")
                                        # The fetcher loader redirect should be ignored
                                    await 
                                        _ A.loaders.foo.redirect("/baz")
                                        # The fetcher loader redirect should be ignored
                                    _ expect(t.router.state.fetchers.get(key)?.state).toBe("idle")
                                    await 
                                        _ B.loaders.bar.resolve("BAR")
                                    _ expect(t.router.state).toMatchObject
                                        { 
                                            @ navigation IDLE_NAVIGATION
                                            { location
                                                @ pathname "/bar"
                                            { loaderData
                                                @ root "ROOT"
                                                @ bar "BAR"
                                    _ expect(t.router.state.fetchers.get(key)?.state).toBe("idle")
                                    _ expect(t.router.state.fetchers.get(key)?.data).toBeUndefined()
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) fetch POST /foo |--R&lf;
                            + &nbsp;     B) nav   GET  /bar   |---O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "ignores submission redirect navigation if preceded by a normal GET navigation"
                                async=> 
                                    let key = "key"
                                    let t = initializeTest()
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                @ key
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    let B
                                        await 
                                            _ t.navigate("/bar")
                                        # This redirect should be ignored
                                    await 
                                        _ A.actions.foo.redirect("/baz")
                                        # This redirect should be ignored
                                    _ expect(t.router.state.fetchers.get(key)?.state).toBe("idle")
                                    await 
                                        _ B.loaders.root.resolve("ROOT*")
                                    await 
                                        _ B.loaders.bar.resolve("BAR")
                                    _ expect(t.router.state).toMatchObject
                                        { 
                                            @ navigation IDLE_NAVIGATION
                                            { location
                                                @ pathname "/bar"
                                            { loaderData
                                                @ root "ROOT*"
                                                @ bar "BAR"
                                    _ expect(t.router.state.fetchers.get(key)?.state).toBe("idle")
                                    _ expect(t.router.state.fetchers.get(key)?.data).toBeUndefined()
                            _ it
                                @ "ignores submission redirect navigation if preceded by a normal GET navigation (w/o loaders)"
                                async=> 
                                    let key = "key"
                                    let t
                                        _ setup
                                            { 
                                                [ routes
                                                    { 
                                                        @ path ""
                                                        @ id "root"
                                                        [ children
                                                            { 
                                                                @ path "/"
                                                                @ id "index"
                                                            { 
                                                                @ path "/foo"
                                                                @ id "foo"
                                                                @ action true
                                                            { 
                                                                @ path "/bar"
                                                                @ id "bar"
                                                            { 
                                                                @ path "/baz"
                                                                @ id "baz"
                                    let A
                                        await 
                                            _ t.fetch
                                                @ "/foo"
                                                @ key
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                                @ key "value"
                                    await 
                                        _ t.navigate("/bar")
                                        # This redirect should be ignored
                                    await 
                                        _ A.actions.foo.redirect("/baz")
                                        # This redirect should be ignored
                                    _ expect(t.router.state.fetchers.get(key)?.state).toBe("idle")
                                    _ expect(t.router.state).toMatchObject
                                        { 
                                            @ navigation IDLE_NAVIGATION
                                            { location
                                                @ pathname "/bar"
                                            { loaderData
                                    _ expect(t.router.state.fetchers.get(key)?.state).toBe("idle")
                                    _ expect(t.router.state.fetchers.get(key)?.data).toBeUndefined()
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) fetch GET /foo |--R     |---O&lf;
                            + &nbsp;     B) nav   POST /bar   |--|--|---O&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "ignores loader redirect navigation if preceded by a normal POST navigation"
                                async=> 
                                    let key = "key"
                                    let t = initializeTest()
                                        # Start a fetch load and interrupt with a POST navigation
                                    let A
                                        await 
                                            _ t.fetch("/foo", key)
                                        # Start a fetch load and interrupt with a POST navigation
                                    let B
                                        await 
                                            _ t.navigate
                                                @ "/bar"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                [ 
                                                    @ "foo"
                                        # The fetcher loader redirect should be ignored
                                    await 
                                        _ A.loaders.foo.redirect("/baz")
                                        # The fetcher loader redirect should be ignored
                                    _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                                        # The navigation should trigger the fetcher to revalidate since it's
                                        # not yet "completed".  If it returns data this time that should be
                                        # reflected
                                    await 
                                        _ B.actions.bar.resolve("ACTION")
                                        # The navigation should trigger the fetcher to revalidate since it's
                                        # not yet "completed".  If it returns data this time that should be
                                        # reflected
                                    await 
                                        _ B.loaders.root.resolve("ROOT*")
                                    await 
                                        _ B.loaders.bar.resolve("BAR")
                                    await 
                                        _ B.loaders.foo.resolve("FOO")
                                    _ expect(t.router.state).toMatchObject
                                        { 
                                            @ navigation IDLE_NAVIGATION
                                            { location
                                                @ pathname "/bar"
                                            { loaderData
                                                @ root "ROOT*"
                                                @ bar "BAR"
                                    _ expect(t.router.state.fetchers.get(key)?.state).toBe("idle")
                                    _ expect(t.router.state.fetchers.get(key)?.data).toBe("FOO")
                            _ it
                                @ "processes second fetcher load redirect after interruption by normal POST navigation"
                                async=> 
                                    let key = "key"
                                    let t = initializeTest()
                                        # Start a fetch load and interrupt with a POST navigation
                                    let A
                                        await 
                                            _ t.fetch("/foo", key, "root")
                                        # Start a fetch load and interrupt with a POST navigation
                                    let B
                                        await 
                                            _ t.navigate
                                                @ "/bar"
                                                { 
                                                    @ formMethod "post"
                                                    @ formData
                                                        _ createFormData
                                                            { 
                                                [ 
                                                    @ "foo"
                                    _ expect(A.loaders.foo.signal.aborted).toBe(true)
                                        # The fetcher loader redirect should be ignored
                                    await 
                                        _ A.loaders.foo.redirect("/baz")
                                        # The fetcher loader redirect should be ignored
                                    _ expect(t.router.state).toMatchObject
                                        { 
                                            { navigation
                                                { location
                                                    @ pathname "/bar"
                                            { location
                                                @ pathname "/"
                                    _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                                        # The navigation should trigger the fetcher to revalidate since it's
                                        # not yet "completed".  If it redirects again we should follow that
                                    await 
                                        _ B.actions.bar.resolve("ACTION")
                                        # The navigation should trigger the fetcher to revalidate since it's
                                        # not yet "completed".  If it redirects again we should follow that
                                    await 
                                        _ B.loaders.root.resolve("ROOT*")
                                    await 
                                        _ B.loaders.bar.resolve("BAR")
                                    let C
                                        await 
                                            _ B.loaders.foo.redirect
                                                @ "/foo/bar"
                                                @ undefined
                                                @ undefined
                                                [ 
                                                    @ "foo"
                                    _ expect(t.router.state).toMatchObject
                                        { 
                                            { navigation
                                                { location
                                                    @ pathname "/foo/bar"
                                            { location
                                                @ pathname "/"
                                            { loaderData
                                                @ root "ROOT"
                                    _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                                        # The fetcher should not revalidate here since it triggered the redirect
                                    await 
                                        _ C.loaders.root.resolve("ROOT**")
                                        # The fetcher should not revalidate here since it triggered the redirect
                                    await 
                                        _ C.loaders.foobar.resolve("FOOBAR")
                                    _ expect(t.router.state).toMatchObject
                                        { 
                                            @ navigation IDLE_NAVIGATION
                                            { location
                                                @ pathname "/foo/bar"
                                            { loaderData
                                                @ root "ROOT**"
                                                @ foobar "FOOBAR"
                                    _ expect(t.router.state.fetchers.get(key)?.state).toBe("idle")
                                    _ expect(t.router.state.fetchers.get(key)?.data).toBe(undefined)
                    _ describe
                        `lit 
                            + &lf;
                            + &nbsp;     A) fetch GET /foo |-----X&lf;
                            + &nbsp;     B) fetch GET /bar  |---R&lf;
                            + &nbsp;  &nbsp;
                        => 
                            _ it
                                @ "handles racing fetcher loader redirects"
                                async=> 
                                    let keyA = "a"
                                    let keyB = "b"
                                    let t = initializeTest()
                                        # Start 2 fetch loads
                                    let A
                                        await 
                                            _ t.fetch("/foo", keyA, "root")
                                        # Start 2 fetch loads
                                    let B
                                        await 
                                            _ t.fetch("/bar", keyB, "root")
                                        # Return a redirect from the second fetcher.load
                                    let C
                                        await 
                                            _ B.loaders.bar.redirect("/baz")
                                        # Return a redirect from the second fetcher.load
                                    _ expect(t.router.state).toMatchObject
                                        { 
                                            { navigation
                                                { location
                                                    @ pathname "/baz"
                                            { location
                                                @ pathname "/"
                                    _ expect(t.router.state.fetchers.get(keyA)?.state).toBe("loading")
                                    _ expect(t.router.state.fetchers.get(keyB)?.state).toBe("loading")
                                        # The original fetch load redirect should be ignored
                                    await 
                                        _ A.loaders.foo.redirect("/foo/bar")
                                        # The original fetch load redirect should be ignored
                                    _ expect(t.router.state).toMatchObject
                                        { 
                                            { navigation
                                                { location
                                                    @ pathname "/baz"
                                            { location
                                                @ pathname "/"
                                    _ expect(t.router.state.fetchers.get(keyA)?.state).toBe("idle")
                                    _ expect(t.router.state.fetchers.get(keyB)?.state).toBe("loading")
                                        # Resolve the navigation loader
                                    await 
                                        _ C.loaders.baz.resolve("BAZ")
                                        # Resolve the navigation loader
                                    _ expect(t.router.state).toMatchObject
                                        { 
                                            @ navigation IDLE_NAVIGATION
                                            { location
                                                @ pathname "/baz"
                                            { loaderData
                                                @ root "ROOT"
                                                @ baz "BAZ"
                                    _ expect(t.router.state.fetchers.get(keyA)?.state).toBe("idle")
                                    _ expect(t.router.state.fetchers.get(keyB)?.state).toBe("idle")
            _ describe
                @ "fetcher revalidation"
                => 
                    _ it
                        @ "revalidates fetchers on action submissions"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        @ routes TASK_ROUTES
                                        [ initialEntries
                                            @ "/"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ index "INDEX"
                            _ expect(t.router.state.navigation).toBe(IDLE_NAVIGATION)
                            let key1 = "key1"
                            let A
                                await 
                                    _ t.fetch("/tasks/1", key1)
                            await 
                                _ A.loaders.tasksId.resolve("TASKS 1")
                            _ expect(A.fetcher.state).toBe("idle")
                            _ expect(A.fetcher.data).toBe("TASKS 1")
                            let C
                                await 
                                    _ t.navigate
                                        @ "/tasks"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                # Add a helper for the fetcher that will be revalidating
                            _ t.shimHelper(C.loaders, "navigation", "loader", "tasksId")
                                # Add a helper for the fetcher that will be revalidating
                                # Resolve the action
                            await 
                                _ C.actions.tasks.resolve("TASKS ACTION")
                                # Resolve the action
                                # Fetcher should go back into a loading state
                            _ expect(t.router.state.fetchers.get(key1)?.state).toBe("loading")
                                # Fetcher should go back into a loading state
                                # Resolve navigation loaders + fetcher loader
                            await 
                                _ C.loaders.root.resolve("ROOT*")
                                # Resolve navigation loaders + fetcher loader
                            await 
                                _ C.loaders.tasks.resolve("TASKS LOADER")
                            await 
                                _ C.loaders.tasksId.resolve("TASKS ID*")
                            _ expect(t.router.state.fetchers.get(key1)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "TASKS ID*"
                                # If a fetcher does a submission, it unsets the revalidation aspect
                            let D
                                await 
                                    _ t.fetch
                                        @ "/tasks/3"
                                        @ key1
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                # If a fetcher does a submission, it unsets the revalidation aspect
                            await 
                                _ D.actions.tasksId.resolve("TASKS 3")
                            await 
                                _ D.loaders.root.resolve("ROOT**")
                            await 
                                _ D.loaders.tasks.resolve("TASKS**")
                            _ expect(t.router.state.fetchers.get(key1)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "TASKS 3"
                            let E
                                await 
                                    _ t.navigate
                                        @ "/tasks"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                            await 
                                _ E.actions.tasks.resolve("TASKS ACTION")
                            await 
                                _ E.loaders.root.resolve("ROOT***")
                            await 
                                _ E.actions.tasks.resolve("TASKS***")
                                # Remains the same state as it was after the submission
                            _ expect(t.router.state.fetchers.get(key1)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "TASKS 3"
                                # Remains the same state as it was after the submission
                    _ it
                        @ "revalidates fetchers on action redirects"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        @ routes TASK_ROUTES
                                        [ initialEntries
                                            @ "/"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ index "INDEX"
                            _ expect(t.router.state.navigation).toBe(IDLE_NAVIGATION)
                            let key = "key"
                            let A
                                await 
                                    _ t.fetch("/tasks/1", key)
                            await 
                                _ A.loaders.tasksId.resolve("TASKS ID")
                            _ expect(A.fetcher.state).toBe("idle")
                            _ expect(A.fetcher.data).toBe("TASKS ID")
                            let C
                                await 
                                    _ t.navigate
                                        @ "/tasks"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                # Redirect the action
                            let D
                                await 
                                    _ C.actions.tasks.redirect
                                        @ "/"
                                        @ undefined
                                        @ undefined
                                        [ 
                                            @ "tasksId"
                                # Redirect the action
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                                # Resolve navigation loaders + fetcher loader
                            await 
                                _ D.loaders.root.resolve("ROOT*")
                                # Resolve navigation loaders + fetcher loader
                            await 
                                _ D.loaders.index.resolve("INDEX*")
                            await 
                                _ D.loaders.tasksId.resolve("TASKS ID*")
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "TASKS ID*"
                    _ it
                        @ "revalidates fetchers on action errors"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        @ routes TASK_ROUTES
                                        [ initialEntries
                                            @ "/"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ index "INDEX"
                            _ expect(t.router.state.navigation).toBe(IDLE_NAVIGATION)
                            let key = "key"
                            let A
                                await 
                                    _ t.fetch("/tasks/1", key)
                            await 
                                _ A.loaders.tasksId.resolve("TASKS ID")
                            _ expect(A.fetcher.state).toBe("idle")
                            _ expect(A.fetcher.data).toBe("TASKS ID")
                            let C
                                await 
                                    _ t.navigate
                                        @ "/tasks"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                            _ t.shimHelper(C.loaders, "navigation", "loader", "tasksId")
                                # Reject the action
                            await 
                                _ C.actions.tasks.reject(Error("Kaboom!"))
                                # Reject the action
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                                # Resolve navigation loaders + fetcher loader
                            await 
                                _ C.loaders.root.resolve("ROOT*")
                                # Resolve navigation loaders + fetcher loader
                            await 
                                _ C.loaders.tasksId.resolve("TASKS ID*")
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "TASKS ID*"
                    _ it
                        @ "does not revalidate fetchers on searchParams changes"
                        async=> 
                            let key = "key"
                            let t
                                _ setup
                                    { 
                                        @ routes TASK_ROUTES
                                        [ initialEntries
                                            @ "/tasks/1"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ taskId "TASK 1"
                            let A
                                await 
                                    _ t.fetch("/?index", key)
                            await 
                                _ A.loaders.index.resolve("FETCH 1")
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "FETCH 1"
                            let B
                                await 
                                    _ t.navigate
                                        @ "/tasks/1?key=value"
                                        @ undefined
                                        [ 
                                            @ "index"
                            await 
                                _ B.loaders.root.resolve("ROOT 2")
                            await 
                                _ B.loaders.tasksId.resolve("TASK 2")
                            _ expect(t.router.state.loaderData).toMatchObject
                                { 
                                    @ root "ROOT 2"
                                    @ tasksId "TASK 2"
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "FETCH 1"
                            _ expect(B.loaders.index.stub).not.toHaveBeenCalled()
                    _ it
                        @ "revalidates fetchers on links to the current location"
                        async=> 
                            let key = "key"
                            let t
                                _ setup
                                    { 
                                        @ routes TASK_ROUTES
                                        [ initialEntries
                                            @ "/tasks/1"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ taskId "TASK 1"
                            let A
                                await 
                                    _ t.fetch("/?index", key)
                            await 
                                _ A.loaders.index.resolve("FETCH 1")
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "FETCH 1"
                            let B
                                await 
                                    _ t.navigate
                                        @ "/tasks/1"
                                        @ undefined
                                        [ 
                                            @ "index"
                            await 
                                _ B.loaders.root.resolve("ROOT 2")
                            await 
                                _ B.loaders.tasksId.resolve("TASK 2")
                            _ expect(t.router.state.loaderData).toMatchObject
                                { 
                                    @ root "ROOT 2"
                                    @ tasksId "TASK 2"
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "FETCH 1"
                            _ expect(B.loaders.index.stub).not.toHaveBeenCalled()
                    _ it
                        @ "does not revalidate idle fetchers when a loader navigation is performed"
                        async=> 
                            let key = "key"
                            let t
                                _ setup
                                    { 
                                        @ routes TASK_ROUTES
                                        [ initialEntries
                                            @ "/"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ index "INDEX"
                            let A
                                await 
                                    _ t.fetch("/", key)
                            await 
                                _ A.loaders.root.resolve("ROOT FETCH")
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "ROOT FETCH"
                            let B
                                await 
                                    _ t.navigate("/tasks")
                            await 
                                _ B.loaders.tasks.resolve("TASKS")
                            _ expect(t.router.state.loaderData).toMatchObject
                                { 
                                    @ root "ROOT"
                                    @ tasks "TASKS"
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "ROOT FETCH"
                    _ it
                        @ "respects shouldRevalidate for the fetcher route"
                        async=> 
                            let key = "key"
                            let count = 0
                            let shouldRevalidate
                                _ jest.fn
                                    => 
                                        param args
                                        + false
                            let router
                                _ createRouter
                                    { 
                                        @ history
                                            _ createMemoryHistory
                                                { 
                                                    [ initialEntries
                                                        @ "/one"
                                        [ routes
                                            { 
                                                @ id "root"
                                                @ path "/"
                                                @ loader
                                                    => 
                                                        _ Promise.resolve(++count)
                                                [ children
                                                    { 
                                                        @ path ":a"
                                                        [ children
                                                            { 
                                                                @ path ":b"
                                                                @ action
                                                                    => 
                                                                        _ Promise.resolve(null)
                                            { 
                                                @ id "fetch"
                                                @ path "/fetch"
                                                @ loader
                                                    => 
                                                        _ Promise.resolve(++count)
                                                @ shouldRevalidate
                                        { hydrationData
                                            { loaderData
                                                @ root count
                            _ expect(router.state.loaderData).toMatchObject
                                { 
                                    @ root 0
                            _ expect(router.getFetcher(key)).toBe(IDLE_FETCHER)
                                # Fetch from a different route
                            _ router.fetch(key, "root", "/fetch")
                                # Fetch from a different route
                            await 
                                _ tick()
                            _ expect(router.getFetcher(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data 1
                                # Post to the current route
                            _ router.navigate
                                @ "/two/three"
                                { 
                                    @ formMethod "post"
                                    @ formData
                                        _ createFormData
                                            { 
                                # Post to the current route
                            await 
                                _ tick()
                            _ expect(router.state.loaderData).toMatchObject
                                { 
                                    @ root 2
                            _ expect(router.getFetcher(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data 1
                            _ expect(shouldRevalidate.mock.calls[0][0]).toMatchInlineSnapshot
                                `lit 
                                    + &lf;
                                    + &nbsp;       {&lf;
                                    + &nbsp;         "actionResult": null,&lf;
                                    + &nbsp;         "currentParams": {&lf;
                                    + &nbsp;           "a": "one",&lf;
                                    + &nbsp;         },&lf;
                                    + &nbsp;         "currentUrl": "http://localhost/one",&lf;
                                    + &nbsp;         "defaultShouldRevalidate": true,&lf;
                                    + &nbsp;         "formAction": "/two/three",&lf;
                                    + &nbsp;         "formData": FormData {},&lf;
                                    + &nbsp;         "formEncType": "application/x-www-form-urlencoded",&lf;
                                    + &nbsp;         "formMethod": "post",&lf;
                                    + &nbsp;         "json": undefined,&lf;
                                    + &nbsp;         "nextParams": {&lf;
                                    + &nbsp;           "a": "two",&lf;
                                    + &nbsp;           "b": "three",&lf;
                                    + &nbsp;         },&lf;
                                    + &nbsp;         "nextUrl": "http://localhost/two/three",&lf;
                                    + &nbsp;         "text": undefined,&lf;
                                    + &nbsp;       }&lf;
                                    + &nbsp;    &nbsp;
                            _ expect(router._internalFetchControllers.size).toBe(0)
                            _ router.dispose()
                    _ it
                        @ "handles fetcher revalidation errors"
                        async=> 
                            let key = "key"
                            let t
                                _ setup
                                    { 
                                        @ routes TASK_ROUTES
                                        [ initialEntries
                                            @ "/"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ index "INDEX"
                            _ expect(t.router.state).toMatchObject
                                { 
                                    { loaderData
                                        @ root "ROOT"
                                        @ index "INDEX"
                                    @ errors null
                            let A
                                await 
                                    _ t.fetch("/tasks/1", key)
                            await 
                                _ A.loaders.tasksId.resolve("ROOT FETCH")
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "ROOT FETCH"
                            let B
                                await 
                                    _ t.navigate
                                        @ "/tasks"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                            _ t.shimHelper(B.loaders, "navigation", "loader", "tasksId")
                            await 
                                _ B.actions.tasks.resolve("TASKS ACTION")
                            await 
                                _ B.loaders.root.resolve("ROOT*")
                            await 
                                _ B.loaders.tasks.resolve("TASKS*")
                            await 
                                _ B.loaders.tasksId.reject(Error("Fetcher error"))
                            _ expect(t.router.state).toMatchObject
                                { 
                                    { loaderData
                                        @ root "ROOT*"
                                        @ tasks "TASKS*"
                                    { errors
                                        @ root new Error("Fetcher error")
                                            # Even though tasksId has an error boundary, this bubbles up to
                                            # the root since it's the closest "active" rendered route with an
                                            # error boundary
                            _ expect(t.router.state.fetchers.get(key)).toBe(undefined)
                    _ it
                        @ "revalidates fetchers on fetcher action submissions"
                        async=> 
                            let key = "key"
                            let actionKey = "actionKey"
                            let t
                                _ setup
                                    { 
                                        @ routes TASK_ROUTES
                                        [ initialEntries
                                            @ "/"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ index "INDEX"
                                # Load a fetcher
                            let A
                                await 
                                    _ t.fetch("/tasks/1", key)
                                # Load a fetcher
                            await 
                                _ A.loaders.tasksId.resolve("TASKS ID")
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "TASKS ID"
                                # Submit a fetcher, leaves loaded fetcher untouched
                            let C
                                await 
                                    _ t.fetch
                                        @ "/tasks"
                                        @ actionKey
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                # Submit a fetcher, leaves loaded fetcher untouched
                            _ t.shimHelper(C.loaders, "fetch", "loader", "tasksId")
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "TASKS ID"
                            _ expect(t.router.state.fetchers.get(actionKey)).toMatchObject
                                { 
                                    @ state "submitting"
                                # After action resolves, both fetchers go into a loading state, with
                                # the load fetcher still reflecting it's stale data
                            await 
                                _ C.actions.tasks.resolve("TASKS ACTION")
                                # After action resolves, both fetchers go into a loading state, with
                                # the load fetcher still reflecting it's stale data
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "loading"
                                    @ data "TASKS ID"
                            _ expect(t.router.state.fetchers.get(actionKey)).toMatchObject
                                { 
                                    @ state "loading"
                                    @ data "TASKS ACTION"
                                # All go back to idle on resolutions
                            await 
                                _ C.loaders.root.resolve("ROOT*")
                                # All go back to idle on resolutions
                            await 
                                _ C.loaders.index.resolve("INDEX*")
                            await 
                                _ C.loaders.tasksId.resolve("TASKS ID*")
                            _ expect(t.router.state.loaderData).toMatchObject
                                { 
                                    @ root "ROOT*"
                                    @ index "INDEX*"
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "TASKS ID*"
                            _ expect(t.router.state.fetchers.get(actionKey)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "TASKS ACTION"
                    _ it
                        @ "does not revalidate fetchers initiated from removed routes"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        @ routes TASK_ROUTES
                                        [ initialEntries
                                            @ "/"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ index "INDEX"
                            let key = "key"
                                # Trigger a fetch from the index route
                            let A
                                await 
                                    _ t.fetch("/tasks/1", key, "index")
                                # Trigger a fetch from the index route
                            await 
                                _ A.loaders.tasksId.resolve("TASKS")
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "TASKS"
                                # Navigate such that the index route will be removed
                            let B
                                await 
                                    _ t.navigate
                                        @ "/tasks"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                # Navigate such that the index route will be removed
                                # Resolve the action
                            await 
                                _ B.actions.tasks.resolve("TASKS ACTION")
                                # Resolve the action
                                # Fetcher should remain in an idle state since it's calling route is
                                # being removed
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "TASKS"
                                # Fetcher should remain in an idle state since it's calling route is
                                # being removed
                                # Resolve navigation loaders
                            await 
                                _ B.loaders.root.resolve("ROOT*")
                                # Resolve navigation loaders
                            await 
                                _ B.loaders.tasks.resolve("TASKS LOADER")
                            _ expect(t.router.state.navigation.state).toBe("idle")
                            _ expect(t.router.state.location.pathname).toBe("/tasks")
                                # Fetcher never got called
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "TASKS"
                                # Fetcher never got called
                    _ it
                        @ "cancels in-flight fetcher.loads on action submission and forces reload"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ path "/"
                                                [ children
                                                    { 
                                                        @ id "index"
                                                        @ index true
                                                    { 
                                                        @ id "action"
                                                        @ path "action"
                                                        @ action true
                                                    { 
                                                        @ id "fetchA"
                                                        @ path "fetch-a"
                                                        @ loader true
                                                        @ shouldRevalidate
                                                            => 
                                                                + false
                                                        # fetch A will resolve before the action and will be able to opt-out
                                                    { 
                                                        @ id "fetchB"
                                                        @ path "fetch-b"
                                                        @ loader true
                                                        @ shouldRevalidate
                                                            => 
                                                                + false
                                                        # fetch B will resolve before the action but then issue a second
                                                        # load that gets cancelled.  It will not be able to opt out because
                                                        # of the cancellation
                                                    { 
                                                        @ id "fetchC"
                                                        @ path "fetch-c"
                                                        @ loader true
                                                        @ shouldRevalidate
                                                            => 
                                                                + false
                                                        # fetch C will not before the action, and will not be able to opt
                                                        # out because it has no data
                                        [ initialEntries
                                            @ "/"
                                        { hydrationData
                                            { loaderData
                                                @ index "INDEX"
                            _ expect(t.router.state.navigation).toBe(IDLE_NAVIGATION)
                            let keyA = "a"
                            let A
                                await 
                                    _ t.fetch("/fetch-a", keyA)
                            await 
                                _ A.loaders.fetchA.resolve("A")
                            _ expect(t.router.state.fetchers.get(keyA)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "A"
                            let keyB = "b"
                            let B
                                await 
                                    _ t.fetch("/fetch-b", keyB)
                            await 
                                _ B.loaders.fetchB.resolve("B")
                            _ expect(t.router.state.fetchers.get(keyB)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "B"
                                # Fetch again for B
                            let B2
                                await 
                                    _ t.fetch("/fetch-b", keyB)
                                # Fetch again for B
                            _ expect(t.router.state.fetchers.get(keyB)?.state).toBe("loading")
                                # Start another fetcher which will not resolve prior to the action
                            let keyC = "c"
                                # Start another fetcher which will not resolve prior to the action
                            let C
                                await 
                                    _ t.fetch("/fetch-c", keyC)
                            _ expect(t.router.state.fetchers.get(keyC)?.state).toBe("loading")
                                # Navigation should cancel fetcher and since it has no data
                                # shouldRevalidate should be ignored on subsequent fetch
                            let D
                                await 
                                    _ t.navigate
                                        @ "/action"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                # Navigation should cancel fetcher and since it has no data
                                # shouldRevalidate should be ignored on subsequent fetch
                                # Add a helper for the fetcher that will be revalidating
                            _ t.shimHelper(D.loaders, "navigation", "loader", "fetchA")
                                # Add a helper for the fetcher that will be revalidating
                            _ t.shimHelper(D.loaders, "navigation", "loader", "fetchB")
                            _ t.shimHelper(D.loaders, "navigation", "loader", "fetchC")
                                # Fetcher load aborted and still in a loading state
                            _ expect(t.router.state.navigation.state).toBe("submitting")
                                # Fetcher load aborted and still in a loading state
                            _ expect(A.loaders.fetchA.signal.aborted).toBe(false)
                            _ expect(B.loaders.fetchB.signal.aborted).toBe(false)
                            _ expect(B2.loaders.fetchB.signal.aborted).toBe(true)
                            _ expect(C.loaders.fetchC.signal.aborted).toBe(true)
                            _ expect(t.router.state.fetchers.get(keyA)?.state).toBe("idle")
                            _ expect(t.router.state.fetchers.get(keyB)?.state).toBe("loading")
                            _ expect(t.router.state.fetchers.get(keyC)?.state).toBe("loading")
                            await 
                                _ B.loaders.fetchB.resolve("B")
                                # ignored due to abort
                            await 
                                _ C.loaders.fetchC.resolve("C")
                                # ignored due to abort
                                # ignored due to abort
                                # Resolve the action
                            await 
                                _ D.actions.action.resolve("ACTION")
                                # ignored due to abort
                                # Resolve the action
                            _ expect(t.router.state.navigation.state).toBe("loading")
                            _ expect(t.router.state.fetchers.get(keyA)?.state).toBe("idle")
                            _ expect(t.router.state.fetchers.get(keyB)?.state).toBe("loading")
                            _ expect(t.router.state.fetchers.get(keyC)?.state).toBe("loading")
                                # Resolve fetcher loader
                            await 
                                _ D.loaders.fetchB.resolve("B2")
                                # Resolve fetcher loader
                            await 
                                _ D.loaders.fetchC.resolve("C")
                            _ expect(t.router.state.navigation.state).toBe("idle")
                            _ expect(t.router.state.fetchers.get(keyA)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "A"
                            _ expect(t.router.state.fetchers.get(keyB)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "B2"
                            _ expect(t.router.state.fetchers.get(keyC)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "C"
                    _ it
                        @ "does not cancel pending action navigation on deletion of revalidating fetcher"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        @ routes TASK_ROUTES
                                        [ initialEntries
                                            @ "/"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ index "INDEX"
                            _ expect(t.router.state.navigation).toBe(IDLE_NAVIGATION)
                            let key1 = "key1"
                            let A
                                await 
                                    _ t.fetch("/tasks/1", key1)
                            await 
                                _ A.loaders.tasksId.resolve("TASKS 1")
                            let C
                                await 
                                    _ t.navigate
                                        @ "/tasks"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                # Add a helper for the fetcher that will be revalidating
                            _ t.shimHelper(C.loaders, "navigation", "loader", "tasksId")
                                # Add a helper for the fetcher that will be revalidating
                                # Resolve the action
                            await 
                                _ C.actions.tasks.resolve("TASKS ACTION")
                                # Resolve the action
                                # Fetcher should go back into a loading state
                            _ expect(t.router.state.fetchers.get(key1)).toMatchObject
                                { 
                                    @ state "loading"
                                    @ data "TASKS 1"
                                # Fetcher should go back into a loading state
                                # Delete fetcher in the middle of the revalidation
                            _ t.router.deleteFetcher(key1)
                                # Delete fetcher in the middle of the revalidation
                            _ expect(t.router.state.fetchers.get(key1)).toBeUndefined()
                                # Resolve navigation loaders
                            await 
                                _ C.loaders.root.resolve("ROOT*")
                                # Resolve navigation loaders
                            await 
                                _ C.loaders.tasks.resolve("TASKS LOADER")
                            _ expect(t.router.state).toMatchObject
                                { 
                                    { actionData
                                        @ tasks "TASKS ACTION"
                                    @ errors null
                                    { loaderData
                                        @ tasks "TASKS LOADER"
                                        @ root "ROOT*"
                            _ expect(t.router.state.fetchers.size).toBe(0)
                    _ it
                        @ "does not cancel pending loader navigation on deletion of revalidating fetcher"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        @ routes TASK_ROUTES
                                        [ initialEntries
                                            @ "/"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ index "INDEX"
                            _ expect(t.router.state.navigation).toBe(IDLE_NAVIGATION)
                            let key1 = "key1"
                            let A
                                await 
                                    _ t.fetch("/tasks/1", key1)
                            await 
                                _ A.loaders.tasksId.resolve("TASKS 1")
                                # Submission navigation to trigger revalidations
                            let C
                                await 
                                    _ t.navigate
                                        @ "/tasks"
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                # Submission navigation to trigger revalidations
                            await 
                                _ C.actions.tasks.resolve("TASKS ACTION")
                                # Fetcher should go back into a loading state
                            _ expect(t.router.state.fetchers.get(key1)).toMatchObject
                                { 
                                    @ state "loading"
                                    @ data "TASKS 1"
                                # Fetcher should go back into a loading state
                                # Delete fetcher in the middle of the revalidation
                            _ t.router.deleteFetcher(key1)
                                # Delete fetcher in the middle of the revalidation
                            _ expect(t.router.state.fetchers.get(key1)).toBeUndefined()
                                # Resolve navigation action/loaders
                            await 
                                _ C.loaders.root.resolve("ROOT*")
                                # Resolve navigation action/loaders
                            await 
                                _ C.loaders.tasks.resolve("TASKS LOADER")
                            _ expect(t.router.state).toMatchObject
                                { 
                                    @ errors null
                                    @ navigation IDLE_NAVIGATION
                                    { actionData
                                        @ tasks "TASKS ACTION"
                                    { loaderData
                                        @ tasks "TASKS LOADER"
                                        @ root "ROOT*"
                            _ expect(t.router.state.fetchers.size).toBe(0)
                    _ it
                        @ "does not cancel pending router.revalidate() on deletion of revalidating fetcher"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        @ routes TASK_ROUTES
                                        [ initialEntries
                                            @ "/"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ index "INDEX"
                            _ expect(t.router.state.navigation).toBe(IDLE_NAVIGATION)
                            let key1 = "key1"
                            let A
                                await 
                                    _ t.fetch("/tasks/1", key1)
                            await 
                                _ A.loaders.tasksId.resolve("TASKS 1")
                                # Trigger revalidations
                            let C
                                await 
                                    _ t.revalidate()
                                # Trigger revalidations
                                # Fetcher should not go back into a loading state since it's a revalidation
                            _ expect(t.router.state.fetchers.get(key1)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "TASKS 1"
                                # Fetcher should not go back into a loading state since it's a revalidation
                                # Delete fetcher in the middle of the revalidation
                            _ t.router.deleteFetcher(key1)
                                # Delete fetcher in the middle of the revalidation
                            _ expect(t.router.state.fetchers.get(key1)).toBeUndefined()
                                # Resolve navigation loaders
                            await 
                                _ C.loaders.root.resolve("ROOT*")
                                # Resolve navigation loaders
                            await 
                                _ C.loaders.index.resolve("INDEX*")
                            _ expect(t.router.state).toMatchObject
                                { 
                                    @ errors null
                                    { loaderData
                                        @ root "ROOT*"
                                        @ index "INDEX*"
                            _ expect(t.router.state.fetchers.size).toBe(0)
                    _ it
                        @ "does not cancel pending fetcher submission on deletion of revalidating fetcher"
                        async=> 
                            let key = "key"
                            let actionKey = "actionKey"
                            let t
                                _ setup
                                    { 
                                        @ routes TASK_ROUTES
                                        [ initialEntries
                                            @ "/"
                                        { hydrationData
                                            { loaderData
                                                @ root "ROOT"
                                                @ index "INDEX"
                                # Load a fetcher
                            let A
                                await 
                                    _ t.fetch("/tasks/1", key)
                                # Load a fetcher
                            await 
                                _ A.loaders.tasksId.resolve("TASKS ID")
                                # Submit a fetcher, leaves loaded fetcher untouched
                            let C
                                await 
                                    _ t.fetch
                                        @ "/tasks"
                                        @ actionKey
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                # Submit a fetcher, leaves loaded fetcher untouched
                                # After action resolves, both fetchers go into a loading state, with
                                # the load fetcher still reflecting it's stale data
                            await 
                                _ C.actions.tasks.resolve("TASKS ACTION")
                                # After action resolves, both fetchers go into a loading state, with
                                # the load fetcher still reflecting it's stale data
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "loading"
                                    @ data "TASKS ID"
                            _ expect(t.router.state.fetchers.get(actionKey)).toMatchObject
                                { 
                                    @ state "loading"
                                    @ data "TASKS ACTION"
                                # Delete fetcher in the middle of the revalidation
                            _ t.router.deleteFetcher(key)
                                # Delete fetcher in the middle of the revalidation
                            _ expect(t.router.state.fetchers.get(key)).toBeUndefined()
                                # Resolve only active route loaders since fetcher was deleted
                            await 
                                _ C.loaders.root.resolve("ROOT*")
                                # Resolve only active route loaders since fetcher was deleted
                            await 
                                _ C.loaders.index.resolve("INDEX*")
                            _ expect(t.router.state.loaderData).toMatchObject
                                { 
                                    @ root "ROOT*"
                                    @ index "INDEX*"
                            _ expect(t.router.state.fetchers.get(key)).toBe(undefined)
                            _ expect(t.router.state.fetchers.get(actionKey)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "TASKS ACTION"
                    _ it
                        @ "handles revalidating fetcher when the triggering fetcher is deleted"
                        async=> 
                            let key = "key"
                            let actionKey = "actionKey"
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "root"
                                                @ path "/"
                                                [ children
                                                    { 
                                                        @ id "home"
                                                        @ index true
                                                        @ loader true
                                                    { 
                                                        @ id "action"
                                                        @ path "action"
                                                        @ action true
                                                    { 
                                                        @ id "fetch"
                                                        @ path "fetch"
                                                        @ loader true
                                        { hydrationData
                                            { loaderData
                                                @ home "HOME"
                                # Load a fetcher
                            let A
                                await 
                                    _ t.fetch("/fetch", key)
                                # Load a fetcher
                            await 
                                _ A.loaders.fetch.resolve("FETCH")
                                # Submit a different fetcher, which will trigger revalidation
                            let B
                                await 
                                    _ t.fetch
                                        @ "/action"
                                        @ actionKey
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                # Submit a different fetcher, which will trigger revalidation
                            _ t.shimHelper(B.loaders, "fetch", "loader", "fetch")
                                # After action resolves, both fetchers go into a loading state
                            await 
                                _ B.actions.action.resolve("ACTION")
                                # After action resolves, both fetchers go into a loading state
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                            _ expect(t.router.state.fetchers.get(actionKey)?.state).toBe("loading")
                                # Remove the submitting fetcher (assume it's component unmounts)
                            _ t.router.deleteFetcher(actionKey)
                                # Remove the submitting fetcher (assume it's component unmounts)
                            await 
                                _ B.loaders.home.resolve("HOME*")
                            await 
                                _ B.loaders.fetch.resolve("FETCH*")
                            _ expect(t.router.state.loaderData).toEqual
                                { 
                                    @ home "HOME*"
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "FETCH*"
                            _ expect(t.router.state.fetchers.get(actionKey)).toBeUndefined()
                    _ it
                        @ "does not call shouldRevalidate on POST navigation if fetcher has not yet loaded"
                        async=> 
                            let spy
                                _ jest.fn
                                    => 
                                        + true
                                # This is specifically for a Remix use case where the initial fetcher.load
                                # call hasn't completed (and hasn't even loaded the route module yet), so
                                # there isn't even a shouldRevalidate implementation to access yet.  If
                                # there's no data it should just interrupt the existing load and load again,
                                # it's not a "revalidation"
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "root"
                                                @ path "/"
                                                [ children
                                                    { 
                                                        @ index true
                                                    { 
                                                        @ id "page"
                                                        @ path "page"
                                                        @ action true
                                            { 
                                                @ id "fetch"
                                                @ path "/fetch"
                                                @ loader true
                                                @ shouldRevalidate spy
                            let key = "key"
                            let A
                                await 
                                    _ t.fetch("/fetch", key, "root")
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                                # This should trigger an automatic revalidation of the fetcher since it
                                # hasn't loaded yet
                            let B
                                await 
                                    _ t.navigate
                                        @ "/page"
                                        { 
                                            @ formMethod "post"
                                            @ body
                                                _ createFormData
                                                    { 
                                        [ 
                                            @ "fetch"
                                # This should trigger an automatic revalidation of the fetcher since it
                                # hasn't loaded yet
                            await 
                                _ B.actions.page.resolve("ACTION")
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                            _ expect(A.loaders.fetch.signal.aborted).toBe(true)
                            _ expect(B.loaders.fetch.signal.aborted).toBe(false)
                                # No-op since the original call was aborted
                            await 
                                _ A.loaders.fetch.resolve("A")
                                # No-op since the original call was aborted
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                                # Complete the navigation
                            await 
                                _ B.loaders.fetch.resolve("B")
                                # Complete the navigation
                            _ expect(t.router.state.navigation.state).toBe("idle")
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "B"
                            _ expect(spy).not.toHaveBeenCalled()
                    _ it
                        @ "does not trigger revalidation on GET navigation if fetcher has not yet loaded"
                        async=> 
                            let spy
                                _ jest.fn
                                    => 
                                        + true
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "root"
                                                @ path "/"
                                                [ children
                                                    { 
                                                        @ index true
                                                    { 
                                                        @ id "page"
                                                        @ path "page"
                                                        @ loader true
                                            { 
                                                @ id "fetch"
                                                @ path "/fetch"
                                                @ loader true
                                                @ shouldRevalidate spy
                            let key = "key"
                            let A
                                await 
                                    _ t.fetch("/fetch", key, "root")
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                            let B
                                await 
                                    _ t.navigate("/page")
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("loading")
                            _ expect(A.loaders.fetch.signal.aborted).toBe(false)
                            await 
                                _ A.loaders.fetch.resolve("A")
                            _ expect(t.router.state.fetchers.get(key)?.state).toBe("idle")
                                # Complete the navigation
                            await 
                                _ B.loaders.page.resolve("PAGE")
                                # Complete the navigation
                            _ expect(t.router.state.navigation.state).toBe("idle")
                            _ expect(t.router.state.fetchers.get(key)).toMatchObject
                                { 
                                    @ state "idle"
                                    @ data "A"
                            _ expect(spy).not.toHaveBeenCalled()
            _ describe
                @ "fetcher ?index params"
                => 
                    _ it
                        @ "hits the proper Routes when ?index params are present"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "parent"
                                                @ path "parent"
                                                @ action true
                                                @ loader true
                                                @ shouldRevalidate
                                                    => 
                                                        + false
                                                    # Turn off revalidation after fetcher action submission for this test
                                                [ children
                                                    { 
                                                        @ id "index"
                                                        @ index true
                                                        @ action true
                                                        @ loader true
                                                        @ shouldRevalidate
                                                            => 
                                                                + false
                                                            # Turn off revalidation after fetcher action submission for this test
                                        [ initialEntries
                                            @ "/parent"
                                        { hydrationData
                                            { loaderData
                                                @ parent "PARENT"
                                                @ index "INDEX"
                            let key = "KEY"
                                # fetcher.load()
                            let A
                                await 
                                    _ t.fetch("/parent", key)
                                # fetcher.load()
                            await 
                                _ A.loaders.parent.resolve("PARENT LOADER")
                            _ expect(t.router.getFetcher(key).data).toBe("PARENT LOADER")
                            let B
                                await 
                                    _ t.fetch("/parent?index", key)
                            await 
                                _ B.loaders.index.resolve("INDEX LOADER")
                            _ expect(t.router.getFetcher(key).data).toBe("INDEX LOADER")
                                # fetcher.submit({}, { method: 'get' })
                            let C
                                await 
                                    _ t.fetch
                                        @ "/parent"
                                        @ key
                                        { 
                                            @ formMethod "get"
                                            @ formData
                                                _ createFormData
                                                    { 
                                # fetcher.submit({}, { method: 'get' })
                            await 
                                _ C.loaders.parent.resolve("PARENT LOADER")
                            _ expect(t.router.getFetcher(key).data).toBe("PARENT LOADER")
                            let D
                                await 
                                    _ t.fetch
                                        @ "/parent?index"
                                        @ key
                                        { 
                                            @ formMethod "get"
                                            @ formData
                                                _ createFormData
                                                    { 
                            await 
                                _ D.loaders.index.resolve("INDEX LOADER")
                            _ expect(t.router.getFetcher(key).data).toBe("INDEX LOADER")
                                # fetcher.submit({}, { method: 'post' })
                            let E
                                await 
                                    _ t.fetch
                                        @ "/parent"
                                        @ key
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                                # fetcher.submit({}, { method: 'post' })
                            await 
                                _ E.actions.parent.resolve("PARENT ACTION")
                            _ expect(t.router.getFetcher(key).data).toBe("PARENT ACTION")
                            let F
                                await 
                                    _ t.fetch
                                        @ "/parent?index"
                                        @ key
                                        { 
                                            @ formMethod "post"
                                            @ formData
                                                _ createFormData
                                                    { 
                            await 
                                _ F.actions.index.resolve("INDEX ACTION")
                            _ expect(t.router.getFetcher(key).data).toBe("INDEX ACTION")
                    _ it
                        @ "throws a 404 ErrorResponse without ?index and parent route has no loader"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "parent"
                                                @ path "parent"
                                                [ children
                                                    { 
                                                        @ id "index"
                                                        @ index true
                                                        @ loader true
                                        [ initialEntries
                                            @ "/parent"
                                        { hydrationData
                                            { loaderData
                                                @ index "INDEX"
                            let key = "KEY"
                            await 
                                _ t.fetch("/parent")
                            _ expect(t.router.state.errors).toMatchInlineSnapshot
                                `lit 
                                    + &lf;
                                    + &nbsp;       {&lf;
                                    + &nbsp;         "parent": ErrorResponseImpl {&lf;
                                    + &nbsp;           "data": "Error: No route matches URL "/parent"",&lf;
                                    + &nbsp;           "error": [Error: No route matches URL "/parent"],&lf;
                                    + &nbsp;           "internal": true,&lf;
                                    + &nbsp;           "status": 404,&lf;
                                    + &nbsp;           "statusText": "Not Found",&lf;
                                    + &nbsp;         },&lf;
                                    + &nbsp;       }&lf;
                                    + &nbsp;    &nbsp;
                            _ expect(t.router.getFetcher(key).data).toBe(undefined)
                    _ it
                        @ "throws a 404 ErrorResponse with ?index and index route has no loader"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "parent"
                                                @ path "parent"
                                                @ loader true
                                                [ children
                                                    { 
                                                        @ id "index"
                                                        @ index true
                                        [ initialEntries
                                            @ "/parent"
                                        { hydrationData
                                            { loaderData
                                                @ parent "PARENT"
                            let key = "KEY"
                            await 
                                _ t.fetch("/parent?index")
                            _ expect(t.router.state.errors).toMatchInlineSnapshot
                                `lit 
                                    + &lf;
                                    + &nbsp;       {&lf;
                                    + &nbsp;         "parent": ErrorResponseImpl {&lf;
                                    + &nbsp;           "data": "Error: No route matches URL "/parent?index"",&lf;
                                    + &nbsp;           "error": [Error: No route matches URL "/parent?index"],&lf;
                                    + &nbsp;           "internal": true,&lf;
                                    + &nbsp;           "status": 404,&lf;
                                    + &nbsp;           "statusText": "Not Found",&lf;
                                    + &nbsp;         },&lf;
                                    + &nbsp;       }&lf;
                                    + &nbsp;    &nbsp;
                            _ expect(t.router.getFetcher(key).data).toBe(undefined)
                    _ it
                        @ "throws a 405 ErrorResponse without ?index and parent route has no action"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "parent"
                                                @ path "parent"
                                                [ children
                                                    { 
                                                        @ id "index"
                                                        @ index true
                                                        @ action true
                                        [ initialEntries
                                            @ "/parent"
                            let key = "KEY"
                            await 
                                _ t.fetch
                                    @ "/parent"
                                    { 
                                        @ formMethod "post"
                                        @ formData
                                            _ createFormData
                                                { 
                            _ expect(t.router.state.errors).toMatchInlineSnapshot
                                `lit 
                                    + &lf;
                                    + &nbsp;       {&lf;
                                    + &nbsp;         "parent": ErrorResponseImpl {&lf;
                                    + &nbsp;           "data": "Error: You made a POST request to "/parent" but did not provide an \`action\` for route "parent", so there is no way to handle the request.",&lf;
                                    + &nbsp;           "error": [Error: You made a POST request to "/parent" but did not provide an \`action\` for route "parent", so there is no way to handle the request.],&lf;
                                    + &nbsp;           "internal": true,&lf;
                                    + &nbsp;           "status": 405,&lf;
                                    + &nbsp;           "statusText": "Method Not Allowed",&lf;
                                    + &nbsp;         },&lf;
                                    + &nbsp;       }&lf;
                                    + &nbsp;    &nbsp;
                            _ expect(t.router.getFetcher(key).data).toBe(undefined)
                    _ it
                        @ "throws a 405 ErrorResponse with ?index and index route has no action"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "parent"
                                                @ path "parent"
                                                @ action true
                                                [ children
                                                    { 
                                                        @ id "index"
                                                        @ index true
                                        [ initialEntries
                                            @ "/parent"
                            let key = "KEY"
                            await 
                                _ t.fetch
                                    @ "/parent?index"
                                    { 
                                        @ formMethod "post"
                                        @ formData
                                            _ createFormData
                                                { 
                            _ expect(t.router.state.errors).toMatchInlineSnapshot
                                `lit 
                                    + &lf;
                                    + &nbsp;       {&lf;
                                    + &nbsp;         "parent": ErrorResponseImpl {&lf;
                                    + &nbsp;           "data": "Error: You made a POST request to "/parent?index" but did not provide an \`action\` for route "parent", so there is no way to handle the request.",&lf;
                                    + &nbsp;           "error": [Error: You made a POST request to "/parent?index" but did not provide an \`action\` for route "parent", so there is no way to handle the request.],&lf;
                                    + &nbsp;           "internal": true,&lf;
                                    + &nbsp;           "status": 405,&lf;
                                    + &nbsp;           "statusText": "Method Not Allowed",&lf;
                                    + &nbsp;         },&lf;
                                    + &nbsp;       }&lf;
                                    + &nbsp;    &nbsp;
                            _ expect(t.router.getFetcher(key).data).toBe(undefined)
            _ describe
                @ "fetcher submissions"
                => 
                    _ it
                        @ "serializes body as application/x-www-form-urlencoded"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "root"
                                                @ path "/"
                                                @ action true
                            let body
                                { 
                                    @ a "1"
                            let F
                                await 
                                    _ t.fetch
                                        @ "/"
                                        @ "key"
                                        { 
                                            @ formMethod "post"
                                            @ formEncType "application/x-www-form-urlencoded"
                                            @ body
                            _ expect(t.router.state.fetchers.get("key")?.formData?.get?.("a")).toBe("1")
                            await 
                                _ F.actions.root.resolve("ACTION")
                            _ expect(F.actions.root.stub).toHaveBeenCalledWith
                                { 
                                    { params
                                    @ request expect.any(Request)
                            let request = F.actions.root.stub.mock.calls[0][0].request
                            _ expect(request.method).toBe("POST")
                            _ expect(request.url).toBe("http://localhost/")
                            _ expect(request.headers.get("Content-Type")).toBe("application/x-www-form-urlencoded;charset=UTF-8")
                            _ expect
                                _ 
                                    _ request.formData()
                                    ._ get
                                        @ "a"
                                ._ toBe
                                    @ "1"
                    _ it
                        @ "serializes body as application/json if specified (object)"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "root"
                                                @ path "/"
                                                @ action true
                            let body
                                { 
                                    @ a "1"
                            let F
                                await 
                                    _ t.fetch
                                        @ "/"
                                        @ "key"
                                        { 
                                            @ formMethod "post"
                                            @ formEncType "application/json"
                                            @ body
                            _ expect(t.router.state.fetchers.get("key")?.json).toBe(body)
                            await 
                                _ F.actions.root.resolve("ACTION")
                            _ expect(F.actions.root.stub).toHaveBeenCalledWith
                                { 
                                    { params
                                    @ request expect.any(Request)
                            let request = F.actions.root.stub.mock.calls[0][0].request
                            _ expect(request.method).toBe("POST")
                            _ expect(request.url).toBe("http://localhost/")
                            _ expect(request.headers.get("Content-Type")).toBe("application/json")
                            _ expect
                                await 
                                    _ request.json()
                                ._ toEqual
                                    @ body
                    _ it
                        @ "serializes body as application/json if specified (array)"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "root"
                                                @ path "/"
                                                @ action true
                            let body
                                [ 
                                    @ 1
                                    @ 2
                                    @ 3
                            let F
                                await 
                                    _ t.fetch
                                        @ "/"
                                        @ "key"
                                        { 
                                            @ formMethod "post"
                                            @ formEncType "application/json"
                                            @ body
                            _ expect(t.router.state.fetchers.get("key")?.json).toBe(body)
                            await 
                                _ F.actions.root.resolve("ACTION")
                            _ expect(F.actions.root.stub).toHaveBeenCalledWith
                                { 
                                    { params
                                    @ request expect.any(Request)
                            let request = F.actions.root.stub.mock.calls[0][0].request
                            _ expect(request.method).toBe("POST")
                            _ expect(request.url).toBe("http://localhost/")
                            _ expect(request.headers.get("Content-Type")).toBe("application/json")
                            _ expect
                                await 
                                    _ request.json()
                                ._ toEqual
                                    @ body
                    _ it
                        @ "serializes body as application/json if specified (null)"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "root"
                                                @ path "/"
                                                @ action true
                            let body = null
                            let F
                                await 
                                    _ t.fetch
                                        @ "/"
                                        @ "key"
                                        { 
                                            @ formMethod "post"
                                            @ formEncType "application/json"
                                            @ body
                            _ expect(t.router.state.fetchers.get("key")?.json).toBe(body)
                            await 
                                _ F.actions.root.resolve("ACTION")
                            _ expect(F.actions.root.stub).toHaveBeenCalledWith
                                { 
                                    { params
                                    @ request expect.any(Request)
                            let request = F.actions.root.stub.mock.calls[0][0].request
                            _ expect(request.method).toBe("POST")
                            _ expect(request.url).toBe("http://localhost/")
                            _ expect(request.headers.get("Content-Type")).toBe("application/json")
                            _ expect
                                await 
                                    _ request.json()
                                ._ toEqual
                                    @ body
                    _ it
                        @ "serializes body as text/plain if specified"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "root"
                                                @ path "/"
                                                @ action true
                            let body = "plain text"
                            let F
                                await 
                                    _ t.fetch
                                        @ "/"
                                        @ "key"
                                        { 
                                            @ formMethod "post"
                                            @ formEncType "text/plain"
                                            @ body
                            _ expect(t.router.state.fetchers.get("key")?.text).toBe(body)
                            await 
                                _ F.actions.root.resolve("ACTION")
                            _ expect(F.actions.root.stub).toHaveBeenCalledWith
                                { 
                                    { params
                                    @ request expect.any(Request)
                            let request = F.actions.root.stub.mock.calls[0][0].request
                            _ expect(request.method).toBe("POST")
                            _ expect(request.url).toBe("http://localhost/")
                            _ expect(request.headers.get("Content-Type")).toBe("text/plain;charset=UTF-8")
                            _ expect
                                await 
                                    _ request.text()
                                ._ toEqual
                                    @ body
                    _ it
                        @ "serializes body as text/plain if specified (empty string)"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "root"
                                                @ path "/"
                                                @ action true
                            let body = ""
                            let F
                                await 
                                    _ t.fetch
                                        @ "/"
                                        @ "key"
                                        { 
                                            @ formMethod "post"
                                            @ formEncType "text/plain"
                                            @ body
                            _ expect(t.router.state.fetchers.get("key")?.text).toBe(body)
                            await 
                                _ F.actions.root.resolve("ACTION")
                            _ expect(F.actions.root.stub).toHaveBeenCalledWith
                                { 
                                    { params
                                    @ request expect.any(Request)
                            let request = F.actions.root.stub.mock.calls[0][0].request
                            _ expect(request.method).toBe("POST")
                            _ expect(request.url).toBe("http://localhost/")
                            _ expect(request.headers.get("Content-Type")).toBe("text/plain;charset=UTF-8")
                            _ expect
                                await 
                                    _ request.text()
                                ._ toEqual
                                    @ body
                    _ it
                        @ "serializes body when encType=undefined"
                        async=> 
                            let t
                                _ setup
                                    { 
                                        [ routes
                                            { 
                                                @ id "root"
                                                @ path "/"
                                                @ action true
                            let body
                                { 
                                    @ a "1"
                            let F
                                await 
                                    _ t.fetch
                                        @ "/"
                                        @ "key"
                                        { 
                                            @ formMethod "post"
                                            @ body
                            _ expect(t.router.state.fetchers.get("key")?.formData?.get?.("a")).toBe("1")
                            await 
                                _ F.actions.root.resolve("ACTION")
                            _ expect(F.actions.root.stub).toHaveBeenCalledWith
                                { 
                                    { params
                                    @ request expect.any(Request)
                            let request = F.actions.root.stub.mock.calls[0][0].request
                            _ expect(request.method).toBe("POST")
                            _ expect(request.url).toBe("http://localhost/")
                            _ expect(request.headers.get("Content-Type")).toBe("application/x-www-form-urlencoded;charset=UTF-8")
                            _ expect
                                _ 
                                    _ request.formData()
                                    ._ get
                                        @ "a"
                                ._ toBe
                                    @ "1"
